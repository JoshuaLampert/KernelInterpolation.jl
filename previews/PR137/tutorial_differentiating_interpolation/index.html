<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1D interpolation and differentiation · KernelInterpolation.jl</title><meta name="title" content="1D interpolation and differentiation · KernelInterpolation.jl"/><meta property="og:title" content="1D interpolation and differentiation · KernelInterpolation.jl"/><meta property="twitter:title" content="1D interpolation and differentiation · KernelInterpolation.jl"/><meta name="description" content="Documentation for KernelInterpolation.jl."/><meta property="og:description" content="Documentation for KernelInterpolation.jl."/><meta property="twitter:description" content="Documentation for KernelInterpolation.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/tutorial_differentiating_interpolation/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/tutorial_differentiating_interpolation/"/><link rel="canonical" href="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/tutorial_differentiating_interpolation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KernelInterpolation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../nodesets/">Sets of nodes</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../pdes/">Solving PDEs by collocation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>1D interpolation and differentiation</a><ul class="internal"><li><a class="tocitem" href="#Define-problem-setup-and-perform-interpolation"><span>Define problem setup and perform interpolation</span></a></li><li><a class="tocitem" href="#Finding-a-well-suited-interpolation-method"><span>Finding a well-suited interpolation method</span></a></li><li><a class="tocitem" href="#Applying-differential-operators"><span>Applying differential operators</span></a></li></ul></li><li><a class="tocitem" href="../tutorial_noisy_data/">Dealing with noisy data</a></li></ul></li><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>1D interpolation and differentiation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1D interpolation and differentiation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/docs/src/tutorial_differentiating_interpolation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="One-dimensional-interpolation-and-differentiation"><a class="docs-heading-anchor" href="#One-dimensional-interpolation-and-differentiation">One-dimensional interpolation and differentiation</a><a id="One-dimensional-interpolation-and-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-interpolation-and-differentiation" title="Permalink"></a></h1><p>In this tutorial, we will create a simple one-dimensional interpolation, investigate how to tune the interpolation method, and show how to apply differential operators on the resulting <a href="../ref/#Interpolation"><code>Interpolation</code></a> object.</p><h2 id="Define-problem-setup-and-perform-interpolation"><a class="docs-heading-anchor" href="#Define-problem-setup-and-perform-interpolation">Define problem setup and perform interpolation</a><a id="Define-problem-setup-and-perform-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Define-problem-setup-and-perform-interpolation" title="Permalink"></a></h2><p>We start by defining a simple one-dimensional interpolation problem. We will interpolate the oscillatory function</p><p class="math-container">\[f(x) = \exp(\sin(2x^2)) + 0.1(x - \pi/2)^2\]</p><p>between <span>$x = -3$</span> and <span>$x = 3$</span>. For simplicity, we take 25 equidistant points in the interval <span>$[-3, 3]$</span> as interpolation points.</p><pre><code class="language-julia hljs">using KernelInterpolation
f(x) = exp(sin(2*x[1]^2)) + 0.1*(x[1] - pi/2)^2
x_min = -3
x_max = 3
N = 25
nodeset = NodeSet(LinRange(x_min, x_max, N))
values = f.(nodeset)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25-element Vector{Float64}:
 2.561118346612702
 3.6010482803853834
 2.592967848165464
 1.9848324553623153
 3.9645665583549765
 1.957023058914906
 1.3192182268719703
 1.8124194938335236
 3.143477103401214
 3.003796380105595
 ⋮
 2.5151585726832555
 1.0270213304360754
 0.3767404307950323
 0.8574656301584783
 2.7079294969190593
 0.5711157612469084
 1.0221715213705675
 1.8731723209109972
 0.676162754458826</code></pre><p>Next, we choose the kernel (radial basis function) for the interpolation. We use the Gaussian kernel with a fixed shape parameter of 0.5 and interpolate the function values.</p><pre><code class="language-julia hljs">kernel = GaussKernel{1}(shape_parameter = 0.5)
itp = interpolate(nodeset, values, kernel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Interpolation with 25 nodes, kernel GaussKernel{1}(shape_parameter = 0.5) and polynomial of order 0.</code></pre><p>Let&#39;s plot the interpolated function and the original function on a finer grid to see how well the interpolation works.</p><pre><code class="language-julia hljs">using Plots
many_nodes = NodeSet(LinRange(x_min, x_max, 200))
plot(many_nodes, f, label = &quot;Original function&quot;)
plot!(many_nodes, itp)</code></pre><p><img src="../interpolation_oscillatory.png" alt="Interpolation of one-dimensional oscillatory function"/></p><p>Uhh, that doesn&#39;t look too good. What happened?</p><h2 id="Finding-a-well-suited-interpolation-method"><a class="docs-heading-anchor" href="#Finding-a-well-suited-interpolation-method">Finding a well-suited interpolation method</a><a id="Finding-a-well-suited-interpolation-method-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-well-suited-interpolation-method" title="Permalink"></a></h2><p>We used the <a href="../ref/#KernelInterpolation.GaussKernel"><code>GaussKernel</code></a> with a rather small shape parameter of 0.5, which leads to an ill-conditioned linear system of equations. We can inspect the condition number of the interpolation matrix to confirm this.</p><pre><code class="language-julia hljs">using LinearAlgebra
A = system_matrix(itp)
cond(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6.239147369601393e17</code></pre><p>Here, we used the <a href="../ref/#KernelInterpolation.system_matrix-Tuple{Interpolation}"><code>system_matrix</code></a> function to obtain the interpolation matrix <code>A</code> and calculated the condition number of the matrix. For this specific example the system matrix simply is the <a href="../ref/#KernelInterpolation.kernel_matrix"><code>kernel_matrix</code></a>, but for more sophisticated interpolations the system matrix contains additional parts like the polynomial augmentation. The condition number is a measure of how well-conditioned the matrix is. A large condition number indicates that the matrix is ill-conditioned, which usually leads to high numerical errors. To avoid this, we have different options. We can either increase the shape parameter of the kernel or we can use a different kernel. The <a href="../ref/#KernelInterpolation.GaussKernel"><code>GaussKernel</code></a> is known to be rather ill-conditioned and other kernels like the <a href="../ref/#KernelInterpolation.WendlandKernel"><code>WendlandKernel</code></a> usually lead to better condition numbers. Here, we choose to increase the shape parameter of the Gaussian kernel to 1.8, which makes the interpolation more localized. Note, however, that you might need to choose another kernel if you increase the number of interpolation points.</p><pre><code class="language-julia hljs">kernel = GaussKernel{1}(shape_parameter = 1.8)
itp = interpolate(nodeset, values, kernel)
plot(many_nodes, f, label = &quot;Original function&quot;)
plot!(many_nodes, itp)</code></pre><p><img src="../interpolation_oscillatory_1_5.png" alt="Interpolation of one-dimensional oscillatory function with higher shape parameter"/></p><p>We can see a much better agreement between the original function and the interpolated function. We still observe some undershoots, but this is expected due to the oscillatory nature of the function and the limited number of interpolation points. Let&#39;s confirm that increasing the shape parameter improved the condition number of the interpolation matrix.</p><pre><code class="language-julia hljs">A = system_matrix(itp)
cond(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">57037.29656737549</code></pre><p>Indeed, the condition number is much smaller than before!</p><h2 id="Applying-differential-operators"><a class="docs-heading-anchor" href="#Applying-differential-operators">Applying differential operators</a><a id="Applying-differential-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-differential-operators" title="Permalink"></a></h2><p>Sometimes, we are not only interested in interpolating a function, but also in computing its derivatives. Remember that in the simplest case, where no polynomial augmentation is used, the interpolation <code>itp</code> represents a linear combination</p><p class="math-container">\[s(x) = \sum_{j = 1}^N c_j\phi(\|x - x_j\|_2)\]</p><p>with <span>$\phi$</span> given by the radial basis function, in this case the Gaussian. Because we know <span>$\phi$</span> and its derivatives, we can compute the derivatives of <span>$s$</span> by differentiating the kernel function. For a general dimension <span>$d$</span>, the partial derivative in the <span>$i$</span>-th direction, <span>$i\in\{1,\ldots,d\}$</span>, of the interpolation is then given by</p><p class="math-container">\[\frac{\partial s}{\partial x_i}(x) = \sum_{j = 1}^N c_j\frac{\partial \phi}{\partial x_i}(\|x - x_j\|_2).\]</p><div class="admonition is-info" id="Note-f12ff6ab99a0e33e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f12ff6ab99a0e33e" title="Permalink"></a></header><div class="admonition-body"><p>Although the derivatives of the kernel functions could be computed analytically, KernelInterpolation.jl uses automatic differentiation (AD) by using <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. This allows for flexibility, simplicity, and easier extension, but it might be slower than computing the derivatives analytically.</p></div></div><p>KernelInterpolation.jl already provides some <a href="../ref/#api-diffops">common differential operators</a>. For example, we can compute the first derivative of the interpolation <code>itp</code> at a specific point <code>x</code> by using the <a href="../ref/#KernelInterpolation.PartialDerivative"><code>PartialDerivative</code></a> operator.</p><pre><code class="language-julia hljs">d1 = PartialDerivative(1)
x = 0.0
itp_dx = d1(itp, x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.3128030378004036</code></pre><p>Let&#39;s plot the first derivative of the interpolated function and compare it to the analytical first derivative.</p><pre><code class="language-julia hljs">itp_dx_many_nodes = d1.(Ref(itp), many_nodes)
f_dx(x) = 4*exp(sin(2*x[1]^2))*x[1]*cos(2*x[1]^2) + 0.2*x[1] - pi/10
plot(many_nodes, f_dx, label = &quot;Derivative of original function&quot;)
plot!(many_nodes, itp_dx_many_nodes, label = &quot;Derivative of interpolated function&quot;)</code></pre><img src="bfc063d3.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pdes/">« Solving PDEs by collocation</a><a class="docs-footer-nextpage" href="../tutorial_noisy_data/">Dealing with noisy data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 22:26">Friday 1 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
