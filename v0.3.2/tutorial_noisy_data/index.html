<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dealing with noisy data · KernelInterpolation.jl</title><meta name="title" content="Dealing with noisy data · KernelInterpolation.jl"/><meta property="og:title" content="Dealing with noisy data · KernelInterpolation.jl"/><meta property="twitter:title" content="Dealing with noisy data · KernelInterpolation.jl"/><meta name="description" content="Documentation for KernelInterpolation.jl."/><meta property="og:description" content="Documentation for KernelInterpolation.jl."/><meta property="twitter:description" content="Documentation for KernelInterpolation.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/tutorial_noisy_data/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/tutorial_noisy_data/"/><link rel="canonical" href="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/tutorial_noisy_data/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KernelInterpolation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../nodesets/">Sets of nodes</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../pdes/">Solving PDEs by collocation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_differentiating_interpolation/">1D interpolation and differentiation</a></li><li class="is-active"><a class="tocitem" href>Dealing with noisy data</a><ul class="internal"><li><a class="tocitem" href="#Define-problem-setup-and-perform-interpolation"><span>Define problem setup and perform interpolation</span></a></li><li><a class="tocitem" href="#Use-regularization-to-stabilize-the-approximation"><span>Use regularization to stabilize the approximation</span></a></li><li><a class="tocitem" href="#Use-least-squares-approximation-to-fit-noisy-data"><span>Use least-squares approximation to fit noisy data</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Dealing with noisy data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dealing with noisy data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/docs/src/tutorial_noisy_data.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Dealing-with-noisy-data"><a class="docs-heading-anchor" href="#Dealing-with-noisy-data">Dealing with noisy data</a><a id="Dealing-with-noisy-data-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-noisy-data" title="Permalink"></a></h1><p>This tutorial is based on Chapter 19 of <sup class="footnote-reference"><a id="citeref-Fasshauer2007" href="#footnote-Fasshauer2007">[Fasshauer2007]</a></sup> and will show how we can use regularization techniques and least-squares fitting to deal with noisy data. Most of the code for this tutorial is also available in the two examples <a href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/examples/interpolation/regularization_2d.jl"><code>interpolation/regularization_2d.jl</code></a> and <a href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/examples/interpolation/least_squares_2d.jl"><code>interpolation/least_squares_2d.jl</code></a>.</p><h2 id="Define-problem-setup-and-perform-interpolation"><a class="docs-heading-anchor" href="#Define-problem-setup-and-perform-interpolation">Define problem setup and perform interpolation</a><a id="Define-problem-setup-and-perform-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Define-problem-setup-and-perform-interpolation" title="Permalink"></a></h2><p>We start by defining a simple two-dimensional interpolation problem. We will use the famous Franke function as the target function and add some noise to the function values. The Franke function is defined as</p><p class="math-container">\[f(x, y) = \frac{3}{4}\exp\left(-\frac{(9x - 2)^2}{4} - \frac{(9y - 2)^2}{4}\right) + \frac{3}{4}\exp\left(-\frac{(9x + 1)^2}{49} - \frac{9y + 1}{10}\right) + \frac{1}{2}\exp\left(-\frac{(9x - 7)^2}{4} - \frac{(9y - 3)^2}{4}\right) - \frac{1}{5}\exp\left(-(9x - 4)^2 - (9y - 7)^2\right).\]</p><p>As nodes for the interpolation, we choose a random set of 1089 points in the unit square.</p><pre><code class="language-julia hljs">using KernelInterpolation

function f(x)
    0.75 * exp(-0.25 * ((9 * x[1] - 2)^2 + (9 * x[2] - 2)^2)) +
    0.75 * exp(-(9 * x[1] + 1)^2 / 49 - (9 * x[2] + 1) / 10) +
    0.5 * exp(-0.25 * ((9 * x[1] - 7)^2 + (9 * x[2] - 3)^2)) -
    0.2 * exp(-(9 * x[1] - 4)^2 - (9 * x[2] - 7)^2)
end

N = 1089
nodeset = random_hypercube(N; dim = 2)
values = f.(nodeset)
values_noisy = values .+ 0.03 * randn(N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1089-element Vector{Float64}:
 0.3029049824044999
 0.007118725125058973
 0.04528860376616182
 0.36231409887713417
 0.06938707784711891
 0.5253175040142275
 0.0654540527922201
 0.28170151680198113
 0.16846343115636345
 0.45715714515305583
 ⋮
 0.8234771666095931
 0.0697488633332993
 0.12864620798372187
 0.12288083055950072
 0.27978542413709045
 0.2354269635244437
 1.139597953635973
 0.8901401014907848
 0.10459333154882247</code></pre><p>As kernel, let&#39;s use the <a href="../ref/#KernelInterpolation.ThinPlateSplineKernel"><code>ThinPlateSplineKernel</code></a>, which uses linear augmentation. We start by performing the interpolation based on the noisy data.</p><pre><code class="language-julia hljs">kernel = ThinPlateSplineKernel{dim(nodeset)}()
itp = interpolate(nodeset, values_noisy, kernel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Interpolation with 1089 nodes, kernel ThinPlateSplineKernel{2}() and polynomial of order 2.</code></pre><p>We plot the resulting interpolation and compare it to the original Franke function.</p><pre><code class="language-julia hljs">using Plots
p1 = surface(itp, colorbar = false)
p2 = surface(homogeneous_hypercube(40; dim = 2), f, colorbar = false)

plot(p1, p2, layout = (1, 2))</code></pre><p><img src="../interpolation_noisy.png" alt="Interpolation of noisy function values"/></p><p>We can see that the interpolation looks much rougher than the original Franke function. This is expected since we fit the noisy data too closely. Therefore, we would like to find a way how to stabilize the approximation and reduce the influence of the noise.</p><h2 id="Use-regularization-to-stabilize-the-approximation"><a class="docs-heading-anchor" href="#Use-regularization-to-stabilize-the-approximation">Use regularization to stabilize the approximation</a><a id="Use-regularization-to-stabilize-the-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Use-regularization-to-stabilize-the-approximation" title="Permalink"></a></h2><p>The first possibility to stabilize the approximation is to use regularization. One of the simplest regularization techniques is the L2-regularization (or also known as ridge regression). One way to motivate the L2-regularization is to consider the interpolation problem as a minimization problem. We can write the interpolation problem as</p><p class="math-container">\[\min_{c \in \mathbb{R}^N} \frac{1}{2}c^TAc\]</p><p>subject to the constraint <span>$Ac = f$</span>, where <span>$A$</span> is the interpolation matrix and <code>f</code> the function values. This problem can be solved with the help of Lagrange multipliers and it turns out the solution simply is <span>$c = A^{-1}f$</span> as we already know. The idea of L2-regularization is to relax the condition <span>$Ac = f$</span> and instead of enforcing the equality, we penalize the deviation from the equality by adding the L2-norm of the difference. This leads to the minimization problem</p><p class="math-container">\[\min_{c \in \mathbb{R}^N} \frac{1}{2}c^TAc + \frac{1}{2\lambda}\|Ac - f\|_2^2.\]</p><p>Computing the gradient of this expression with respect to <span>$c$</span> and setting it to zero, we obtain the regularized solution</p><p class="math-container">\[c = (A + \lambda I)^{-1}f\]</p><p>assuming the regularity and symmetry of the interpolation matrix <span>$A$</span>. The parameter <span>$\lambda$</span> is a regularization parameter that controls the trade-off between the interpolation error and the regularization term. The larger <span>$\lambda$</span> is, the more the interpolation is regularized, which leads to a smoother approximation. In practice, this means that we only change the interpolation matrix by adding a constant to the diagonal. Note that the polynomial augmentation is not affected by the regularization. In KernelInterpolation.jl, we can pass a regularizer to the <a href="../ref/#KernelInterpolation.interpolate-Union{Tuple{RealT}, Tuple{Dim}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}, NodeSet{Dim, RealT}}} where {Dim, RealT}"><code>interpolate</code></a> function.</p><pre><code class="language-julia hljs">λ = 0.01
itp_reg = interpolate(nodeset, values_noisy, kernel, regularization = L2Regularization(λ))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Interpolation with 1089 nodes, kernel ThinPlateSplineKernel{2}() and polynomial of order 2.</code></pre><p>Plotting the regularized interpolation, we can see that the approximation is much smoother than the unregularized interpolation and thus much closer to the underlying target function.</p><pre><code class="language-julia hljs">surface(itp_reg, colorbar = false)</code></pre><p><img src="../interpolation_noisy_regularized.png" alt="Regularized interpolation of noisy function values"/></p><p>We compare the stability of the regularized and unregularized interpolation by looking a the condition numbers of the two system matrices.</p><pre><code class="language-julia hljs">using LinearAlgebra
A_itp = system_matrix(itp)
A_itp_reg = system_matrix(itp_reg)
cond(A_itp), cond(A_itp_reg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1.4374214054457164e8, 14904.18153846781)</code></pre><p>We can see that the condition number is drastically reduced from around <code>1.5e8</code> to <code>1.5e4</code> by using regularization. This means that the regularized interpolation is much more stable and less sensitive to the noise in the data.</p><h2 id="Use-least-squares-approximation-to-fit-noisy-data"><a class="docs-heading-anchor" href="#Use-least-squares-approximation-to-fit-noisy-data">Use least-squares approximation to fit noisy data</a><a id="Use-least-squares-approximation-to-fit-noisy-data-1"></a><a class="docs-heading-anchor-permalink" href="#Use-least-squares-approximation-to-fit-noisy-data" title="Permalink"></a></h2><p>As an alternative to using regularization, we can also use least-squares fitting to approximate the noisy data. The idea of least-squares approximation is to use another set of nodes to construct the RBF basis than we use for the interpolation. This means we construct another <code>NodeSet</code> consisting of the <code>centers</code> for the basis functions, which is smaller than the <code>nodeset</code> we use for the interpolation. If the nodeset is given by <span>$X = \{x_1, \ldots, x_N\}$</span> and the <code>centers</code> are <span>$\Xi = \{\xi_1, \ldots, \xi_M\}$</span> with <span>$M \le N$</span>, we obtain a rectangular system matrix <span>$A\in\mathbb{R}^{N\times M}$</span> with <span>$A_{ij} = K(x_j, \xi_k)$</span> for <span>$j = 1, \ldots, N$</span> and <span>$k = 1, \ldots, M$</span>. The overdetermined system <span>$Ac = f$</span> can be solved by the least-squares method. Again, only the kernel matrix part is affected by the least-squares approximation and the polynomial augmentation is not changed. In KernelInterpolation.jl, we can pass <code>centers</code> to the <a href="../ref/#KernelInterpolation.interpolate-Union{Tuple{RealT}, Tuple{Dim}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}, NodeSet{Dim, RealT}}} where {Dim, RealT}"><code>interpolate</code></a> function.</p><pre><code class="language-julia hljs">M = 81
centers = random_hypercube(M; dim = 2)
ls = interpolate(centers, nodeset, values_noisy, kernel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Interpolation with 1089 nodes, kernel ThinPlateSplineKernel{2}() and polynomial of order 2.</code></pre><p>We plot the least-squares approximation and, again, see a better fit to the underlying target function.</p><pre><code class="language-julia hljs">surface(ls, colorbar = false)</code></pre><p><img src="../interpolation_noisy_least_squares.png" alt="Least squares approximation of noisy function values"/></p><p>Finally, we compare the error of the three methods to the true data without noise:</p><pre><code class="language-julia hljs">values_itp = itp.(nodeset)
values_itp_reg = itp_reg.(nodeset)
values_ls = ls.(nodeset)
norm(values_itp .- values), norm(values_itp_reg .- values), norm(values_ls .- values)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.9485050519627003, 0.27177587974773215, 0.29888694210213995)</code></pre><p>which confirms our findings above as the errors of the stabilized schemes are smaller than the error of the unregularized interpolation. Note that we did not put much effort in optimizing the regularization parameter or the number of centers for the least-squares approximation and that there is still room for improvement.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Fasshauer2007"><a class="tag is-link" href="#citeref-Fasshauer2007">Fasshauer2007</a>Fasshauer (2007): Meshfree Approximation Methods with Matlab, World Scientific, <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_differentiating_interpolation/">« 1D interpolation and differentiation</a><a class="docs-footer-nextpage" href="../development/">Development »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 22 May 2025 16:41">Thursday 22 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
