<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · KernelInterpolation.jl</title><meta name="title" content="Reference · KernelInterpolation.jl"/><meta property="og:title" content="Reference · KernelInterpolation.jl"/><meta property="twitter:title" content="Reference · KernelInterpolation.jl"/><meta name="description" content="Documentation for KernelInterpolation.jl."/><meta property="og:description" content="Documentation for KernelInterpolation.jl."/><meta property="twitter:description" content="Documentation for KernelInterpolation.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/ref/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/ref/"/><link rel="canonical" href="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/ref/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KernelInterpolation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../nodesets/">Sets of nodes</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../pdes/">Solving PDEs by collocation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_differentiating_interpolation/">1D interpolation and differentiation</a></li><li><a class="tocitem" href="../tutorial_noisy_data/">Dealing with noisy data</a></li></ul></li><li><a class="tocitem" href="../development/">Development</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#api-kernels"><span>Kernel functions</span></a></li><li><a class="tocitem" href="#Node-sets"><span>Node sets</span></a></li><li><a class="tocitem" href="#Bases"><span>Bases</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Regularization"><span>Regularization</span></a></li><li><a class="tocitem" href="#api-diffops"><span>Differential Operators</span></a></li><li><a class="tocitem" href="#api-equations"><span>Partial differential equations</span></a></li><li><a class="tocitem" href="#Discretization"><span>Discretization</span></a></li><li><a class="tocitem" href="#Kernel-matrices"><span>Kernel matrices</span></a></li><li><a class="tocitem" href="#api-callbacks"><span>Callbacks</span></a></li><li><a class="tocitem" href="#Input/Output"><span>Input/Output</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/docs/src/ref.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="KernelInterpolation.jl-API"><a class="docs-heading-anchor" href="#KernelInterpolation.jl-API">KernelInterpolation.jl API</a><a id="KernelInterpolation.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#KernelInterpolation.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.KernelInterpolation" href="#KernelInterpolation.KernelInterpolation"><code>KernelInterpolation.KernelInterpolation</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KernelInterpolation</code></pre><p><strong>KernelInterpolation.jl</strong> is a Julia package that implements methods for multivariate interpolation in arbitrary dimension based on symmetric (conditionally) positive-definite kernels with a focus on radial basis functions. It can be used for classical interpolation of scattered data, as well as for generalized (Hermite-Birkhoff) interpolation by using a meshfree collocation approach. This can be used to solve partial differential equations both stationary ones and time-dependent ones by using some time integration method from OrdinaryDiffEq.jl.</p><p>See also: <a href="https://github.com/JoshuaLampert/KernelInterpolation.jl">KernelInterpolation.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/KernelInterpolation.jl#L1-L11">source</a></section></article><h2 id="api-kernels"><a class="docs-heading-anchor" href="#api-kernels">Kernel functions</a><a id="api-kernels-1"></a><a class="docs-heading-anchor-permalink" href="#api-kernels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.AbstractKernel" href="#KernelInterpolation.AbstractKernel"><code>KernelInterpolation.AbstractKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractKernel</code></pre><p>An abstract supertype of kernels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/kernels.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.dim-Union{Tuple{KernelInterpolation.AbstractKernel{Dim}}, Tuple{Dim}} where Dim" href="#KernelInterpolation.dim-Union{Tuple{KernelInterpolation.AbstractKernel{Dim}}, Tuple{Dim}} where Dim"><code>KernelInterpolation.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(kernel)</code></pre><p>Return the dimension of a kernel, i.e. the size of the input vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/kernels.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.get_name-Tuple{KernelInterpolation.AbstractKernel}" href="#KernelInterpolation.get_name-Tuple{KernelInterpolation.AbstractKernel}"><code>KernelInterpolation.get_name</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_name(kernel::AbstractKernel)</code></pre><p>Returns the canonical, human-readable name for the given system of equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/kernels.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.GaussKernel" href="#KernelInterpolation.GaussKernel"><code>KernelInterpolation.GaussKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussKernel{Dim}(; shape_parameter = 1.0)</code></pre><p>Gaussian kernel function with</p><p class="math-container">\[    \phi(r) = \exp(-(\varepsilon r)^2),\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The Gaussian kernel is always positive definite. See Wendland (2004), p. 74.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L57-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.InverseMultiquadricKernel" href="#KernelInterpolation.InverseMultiquadricKernel"><code>KernelInterpolation.InverseMultiquadricKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InverseMultiquadricKernel{Dim}(beta = 0.5; shape_parameter = 1.0)</code></pre><p>Inverse multiquadric kernel function with</p><p class="math-container">\[    \phi(r) = (1 + (\varepsilon r)^2)^{-\beta},\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The inverse multiquadric kernel is always positive definite. See Wendland (2004), p. 76 and p. 95.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L125-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Matern12Kernel" href="#KernelInterpolation.Matern12Kernel"><code>KernelInterpolation.Matern12Kernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matern12Kernel{Dim}(; shape_parameter = 1.0)</code></pre><p>Matern kernel with <span>$\nu = 1/2$</span>, i.e.,</p><p class="math-container">\[    \phi(r) = \exp(-\varepsilon r),\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The Matern kernel is positive definite.</p><p>See <a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function">Wikipedia</a> and Fasshauer (2007), p. 41.</p><p>See also <a href="#KernelInterpolation.MaternKernel"><code>MaternKernel</code></a>, <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L483-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Matern32Kernel" href="#KernelInterpolation.Matern32Kernel"><code>KernelInterpolation.Matern32Kernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matern32Kernel{Dim}(; shape_parameter = 1.0)</code></pre><p>Matern kernel with <span>$\nu = 3/2$</span>, i.e.,</p><p class="math-container">\[    \phi(r) =  (1 + \sqrt{3}\varepsilon r)\exp(-\sqrt{3}\varepsilon r),\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The Matern kernel is positive definite.</p><p>See <a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function">Wikipedia</a> and Fasshauer (2007), p. 41.</p><p>See also <a href="#KernelInterpolation.MaternKernel"><code>MaternKernel</code></a>, <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L519-L536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Matern52Kernel" href="#KernelInterpolation.Matern52Kernel"><code>KernelInterpolation.Matern52Kernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matern52Kernel{Dim}(; shape_parameter = 1.0)</code></pre><p>Matern kernel with <span>$\nu = 5/2$</span>, i.e.,</p><p class="math-container">\[    \phi(r) =  (1 + \sqrt{5}\varepsilon r + 5\cdot(\varepsilon r)^2/3)\exp(-\sqrt{5}\varepsilon r),\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The Matern kernel is positive definite.</p><p>See <a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function">Wikipedia</a> and Fasshauer (2007), p. 41.</p><p>See also <a href="#KernelInterpolation.MaternKernel"><code>MaternKernel</code></a>, <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L556-L573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Matern72Kernel" href="#KernelInterpolation.Matern72Kernel"><code>KernelInterpolation.Matern72Kernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matern72Kernel{Dim}(; shape_parameter = 1.0)</code></pre><p>Matern kernel with <span>$\nu = 7/2$</span>, i.e.,</p><p class="math-container">\[    \phi(r) =  (1 + \sqrt{7}\varepsilon r + 12\cdot(\varepsilon r)^2/5 + 7\cdot(\varepsilon r)^3/15)\exp(-\sqrt{7}\varepsilon r),\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The Matern kernel is positive definite.</p><p>See <a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function">Wikipedia</a> and Fasshauer (2007), p. 41.</p><p>See also <a href="#KernelInterpolation.MaternKernel"><code>MaternKernel</code></a>, <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L592-L609">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.MaternKernel" href="#KernelInterpolation.MaternKernel"><code>KernelInterpolation.MaternKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaternKernel{Dim}(nu = 1.5; shape_parameter = 1.0)</code></pre><p>Matern kernel with</p><p class="math-container">\[    \phi_\nu(r) =  \frac{2^{1-\nu}}{\Gamma(\nu)}\big(\sqrt{2\nu}\varepsilon r\big)^\nu K_\nu\big(\sqrt{2\nu}\varepsilon r\big),\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The Matern kernel is positive definite.</p><p>See <a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function">Wikipedia</a> and Fasshauer (2007), p. 41.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L435-L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.MultiquadricKernel" href="#KernelInterpolation.MultiquadricKernel"><code>KernelInterpolation.MultiquadricKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiquadricKernel{Dim}(beta = 0.5; shape_parameter = 1.0)</code></pre><p>Multiquadric kernel function with</p><p class="math-container">\[    \phi(r) = (1 + (\varepsilon r)^2)^\beta,\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The multiquadric kernel is conditionally positive definite of order <span>$m = \lceil\beta \rceil$</span>. See Wendland (2004), p. 109.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L90-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.PolyharmonicSplineKernel" href="#KernelInterpolation.PolyharmonicSplineKernel"><code>KernelInterpolation.PolyharmonicSplineKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolyharmonicSplineKernel{Dim}(k)</code></pre><p>Polyharmonic spline kernel function with</p><p class="math-container">\[    \phi_k(r) = \begin{cases}
        r^k, &amp;\text{ if } k \text{ odd}\\
        r^k\log(r), &amp;\text{ if } k \text{ even}
    \end{cases}.\]</p><p>The polyharmonic spline is conditionally positive definite of order <span>$m = \lceil k/2\rceil$</span> for odd <code>k</code> and order <span>$m = k/2 + 1$</span> for even <code>k</code>. See Wendland (2004), pp. 111–112.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L162-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.RadialCharacteristicKernel" href="#KernelInterpolation.RadialCharacteristicKernel"><code>KernelInterpolation.RadialCharacteristicKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RadialCharacteristicKernel{Dim}(beta = 2.0; shape_parameter = 1.0)</code></pre><p>Radial characteristic function (or also called truncated power or Askey) kernel function with</p><p class="math-container">\[    \phi(r) = (1 - \varepsilon r)^\beta_+,\]</p><p>where <span>$\varepsilon$</span> is the shape parameter. The radial characteristic function is positive definite if <span>$\beta\ge (d + 1)/2$</span>. It is compactly supported. See Wendland (2004), p. 80, Iske (2018), p. 281.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li><li>Armin Iske (2018) Approximation Theory and Algorithms for Data Analysis Texts in Applied Mathematics (Springer) <a href="https://doi.org/10.1007/978-3-030-05228-7">DOI: 10.1007/978-3-030-05228-7</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L392-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.RadialSymmetricKernel" href="#KernelInterpolation.RadialSymmetricKernel"><code>KernelInterpolation.RadialSymmetricKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RadialSymmetricKernel</code></pre><p>An abstract supertype of radial symmetric kernels. Radial symmetric kernels are generated by an even and continuous function <span>$\Phi: \mathbb{R}^d\to\mathbb{R}$</span>, which is radial-symmetric meaning that there exists a <span>$\phi:[0,\infty]\to\mathbb{R}$</span> such that</p><p class="math-container">\[    \Phi(x) = \phi(\Vert x\Vert).\]</p><p>The kernel is then defined by</p><p class="math-container">\[    K(x, y) = \Phi(x - y).\]</p><p>A <code>RadialSymmetricKernel</code> can be evaluated at two points <code>x</code> and <code>y</code> by calling <code>kernel(x, y)</code> or at a single point <code>x</code> by calling <code>kernel(x)</code>, which implicitly sets <code>y</code> to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.RieszKernel" href="#KernelInterpolation.RieszKernel"><code>KernelInterpolation.RieszKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RieszKernel{Dim}(beta; shape_parameter = 1.0)</code></pre><p>Riesz kernel with</p><p class="math-container">\[    \phi(r) =  -(\varepsilon r)^\beta,\]</p><p>where <span>$\varepsilon$</span> is the shape parameter and <span>$\beta\in (0,2)$</span>. The Riesz kernel is conditionally positive definite of order 1. See Hertrich et al. (2023).</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Johannes Hertrich, Christian Wald, Fabian Altekrüger, Paul Hagemann (2023) Generative Sliced MMD Flows with Riesz Kernels <a href="https://arxiv.org/abs/2305.11463">ArXiv: 2305.11463</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L628-L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.ThinPlateSplineKernel" href="#KernelInterpolation.ThinPlateSplineKernel"><code>KernelInterpolation.ThinPlateSplineKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinPlateSplineKernel{Dim}()</code></pre><p>Thin plate spline kernel function with</p><p class="math-container">\[    \phi(r) = r^2\log(r),\]</p><p>i.e., <a href="#KernelInterpolation.PolyharmonicSplineKernel"><code>PolyharmonicSplineKernel</code></a> with <span>$k = 2$</span>. The thin plate spline is conditionally positive definite of order <span>$m = 2$</span>. See Wendland (2004), p. 112.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L210-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.WendlandKernel" href="#KernelInterpolation.WendlandKernel"><code>KernelInterpolation.WendlandKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WendlandKernel{Dim}(k; shape_parameter = 1.0, d = Dim)</code></pre><p>Wendland kernel with</p><p class="math-container">\[    \phi_{d,k}(r) = \begin{cases}
        p_{d,k}(\varepsilon r), \text{ if } 0\le \varepsilon r\le 1\\
        0, \text{ if } \varepsilon r &gt; 1
    \end{cases},\]</p><p>where <span>$\varepsilon$</span> is the shape parameter and <span>$p$</span> is a polynomial with minimal degree. The Wendland kernel is positive definite for <code>d\le Dim</code> and compactly supported. See Wendland (2004), p. 129 or Fasshauer (2007), pp. 87–88.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Holger Wendland (2004) Scattered Data Approximation Cambridge University Press <a href="https://doi.org/10.1017/CBO9780511617539">DOI: 10.1017/CBO9780511617539</a></li><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L237-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.WuKernel" href="#KernelInterpolation.WuKernel"><code>KernelInterpolation.WuKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WuKernel{Dim}(l, k; shape_parameter = 1.0)</code></pre><p>Wu kernel with</p><p class="math-container">\[    \phi_{l,k}(r) = \begin{cases}
        p_{l,k}(\varepsilon r), \text{ if } 0\le \varepsilon r\le 1\\
        0, \text{ if } \varepsilon r &gt; 1
    \end{cases},\]</p><p>where <span>$\varepsilon$</span> is the shape parameter, <span>$k\le l$</span>, and <span>$p$</span> is a polynomial of degree <span>$4l - 2k + 1$</span>. The Wu kernel is positive definite for <span>$Dim\le 2k + 1$</span> and compactly supported. See Fasshauer (2007), pp. 88–90 and Wu (1995).</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>.</p><ul><li>Gregory Fasshauer (2007) Meshfree Approximation Methods with MATLAB World Scientific <a href="https://doi.org/10.1142/6437">DOI: 10.1142/6437</a></li><li>Zongmin Wu (1995) Compactly supported positive definite radial functions Advances in Computational Mathematics <a href="https://doi.org/10.1007/BF03177517">DOI: 10.1007/BF03177517</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L305-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Phi-Union{Tuple{Dim}, Tuple{KernelInterpolation.RadialSymmetricKernel{Dim}, Any}} where Dim" href="#KernelInterpolation.Phi-Union{Tuple{Dim}, Tuple{KernelInterpolation.RadialSymmetricKernel{Dim}, Any}} where Dim"><code>KernelInterpolation.Phi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Phi(kernel, x)</code></pre><p>For a <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a> <code>kernel</code> return value of the multivariate function <span>$\Phi$</span> defined by <span>$\Phi(x) = \phi(\Vert x\Vert)$</span>.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>, <a href="#KernelInterpolation.phi"><code>phi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.order" href="#KernelInterpolation.order"><code>KernelInterpolation.order</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(kernel)</code></pre><p>Return order of kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.phi" href="#KernelInterpolation.phi"><code>KernelInterpolation.phi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi(kernel, r)</code></pre><p>For a <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a> <code>kernel</code> return value of the univariate function <span>$\phi$</span> defining the kernel.</p><p>See also <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a>, <a href="#KernelInterpolation.Phi-Union{Tuple{Dim}, Tuple{KernelInterpolation.RadialSymmetricKernel{Dim}, Any}} where Dim"><code>Phi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/radialsymmetric_kernel.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.ProductKernel" href="#KernelInterpolation.ProductKernel"><code>KernelInterpolation.ProductKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProductKernel{Dim}(kernels)</code></pre><p>Given a vector of <code>kernels</code>, construct a new kernel that multiplies the results of the component kernels, i.e., the new kernel <span>$K$</span> is given by</p><p class="math-container">\[    K(x, y) = \prod_{i = 1}^n K_i(x, y),\]</p><p>where <span>$K_i$</span> are the component kernels and <span>$n$</span> the number of kernels. Note that all component kernels need to have the same <a href="#KernelInterpolation.dim-Union{Tuple{KernelInterpolation.AbstractKernel{Dim}}, Tuple{Dim}} where Dim"><code>dim</code></a>. A <code>ProductKernel</code> can also be constructed using the <code>*</code> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/special_kernel.jl#L37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.SumKernel" href="#KernelInterpolation.SumKernel"><code>KernelInterpolation.SumKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SumKernel{Dim}(kernels)</code></pre><p>Given a vector of <code>kernels</code>, construct a new kernel that sums the results of the component kernels, i.e., the new kernel <span>$K$</span> is given by</p><p class="math-container">\[    K(x, y) = \sum_{i = 1}^n K_i(x, y),\]</p><p>where <span>$K_i$</span> are the component kernels and <span>$n$</span> the number of kernels. Note that all component kernels need to have the same <a href="#KernelInterpolation.dim-Union{Tuple{KernelInterpolation.AbstractKernel{Dim}}, Tuple{Dim}} where Dim"><code>dim</code></a>. A <code>SumKernel</code> can also be constructed using the <code>+</code> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/special_kernel.jl#L84-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.TransformationKernel" href="#KernelInterpolation.TransformationKernel"><code>KernelInterpolation.TransformationKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransformationKernel{Dim}(kernel, transformation)</code></pre><p>Given a base <code>kernel</code> and a bijective <code>transformation</code> function, construct a new kernel that applies the transformation to both arguments <span>$x$</span> and <span>$y$</span>, i.e., the new kernel <span>$K_T$</span> is given by</p><p class="math-container">\[    K_T(x, y) = K(Tx, Ty),\]</p><p>where <span>$K$</span> is the base <code>kernel</code> and <span>$T$</span> the transformation, i.e. if <span>$K$</span> is a kernel of dimension <span>$d$</span>, <span>$T$</span> is a function from dimension <code>Dim</code> to <span>$d$</span>, where <code>Dim</code> is the dimension of the new kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernels/special_kernel.jl#L1-L13">source</a></section></article><h2 id="Node-sets"><a class="docs-heading-anchor" href="#Node-sets">Node sets</a><a id="Node-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Node-sets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.NodeSet" href="#KernelInterpolation.NodeSet"><code>KernelInterpolation.NodeSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NodeSet(nodes)</code></pre><p>Set of interpolation nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.distance_matrix-Tuple{NodeSet, NodeSet}" href="#KernelInterpolation.distance_matrix-Tuple{NodeSet, NodeSet}"><code>KernelInterpolation.distance_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_matrix(nodeset1::NodeSet, nodeset2::NodeSet)</code></pre><p>Compute the distance matrix between two <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s, which is a matrix <span>$D$</span> with <span>$D_{ij} = \|x_i - \xi_j\|$</span> for all <span>$i$</span> and <span>$j$</span>, where <span>$x_i$</span> are the nodes in <code>nodeset1</code> and <span>$\xi_j$</span> are the nodes on <code>nodeset2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.empty_nodeset" href="#KernelInterpolation.empty_nodeset"><code>KernelInterpolation.empty_nodeset</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">empty_nodeset(Dim, RealT = Float64)</code></pre><p>Create an empty <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.homogeneous_hypercube" href="#KernelInterpolation.homogeneous_hypercube"><code>KernelInterpolation.homogeneous_hypercube</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">homogeneous_hypercube(n, x_min = ntuple(_ -&gt; 0.0, dim), x_max = ntuple(_ -&gt; 1.0, dim); [dim])</code></pre><p>If <code>n</code> is integer, create a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> with <code>n</code> homogeneously distributed nodes in every dimension each of dimension <code>dim</code> inside a hypercube defined by the bounds <code>x_min</code> and <code>x_max</code>. If <code>n</code> is a <code>Tuple</code> of length <code>dim</code>, then use as many nodes in each dimension as described by <code>n</code>. The resulting <code>NodeSet</code> will have <span>$n^{\textrm{dim}}$</span> respectively <span>$\prod_{j = 1}^{\textrm{dim}}n_j$</span> points. If the bounds are given as single values, they are applied for each dimension. If they are <code>Tuple</code>s of size <code>dim</code>, the hypercube has the according bounds. If <code>dim</code> is not given explicitly, it is inferred by the lengths of <code>n</code>, <code>x_min</code> and <code>x_max</code> if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L303-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.homogeneous_hypercube_boundary" href="#KernelInterpolation.homogeneous_hypercube_boundary"><code>KernelInterpolation.homogeneous_hypercube_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">homogeneous_hypercube_boundary(n, x_min = ntuple(_ -&gt; 0.0, dim), x_max = ntuple(_ -&gt; 1.0, dim); [dim])</code></pre><p>If <code>n</code> is integer, create a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> with <code>n</code> homogeneously distributed nodes in every dimension each of dimension <code>dim</code> on the boundary of a hypercube defined by the bounds <code>x_min</code> and <code>x_max</code>. If <code>n</code> is a <code>Tuple</code> of length <code>dim</code>, then use as many nodes in each dimension as described by <code>n</code>. If the bounds are given as single values, they are applied for each dimension. If they are <code>Tuple</code>s of size <code>dim</code>, the hypercube has the according bounds. If <code>dim</code> is not given explicitly, it is inferred by the lengths of <code>n</code>, <code>x_min</code> and <code>x_max</code> if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L347-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.random_hypercube" href="#KernelInterpolation.random_hypercube"><code>KernelInterpolation.random_hypercube</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_hypercube([rng], n, x_min = ntuple(_ -&gt; 0.0, dim), x_max = ntuple(_ -&gt; 1.0, dim); [dim])</code></pre><p>Create a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> with <code>n</code> random nodes each of dimension <code>dim</code> inside a hypercube defined by the bounds <code>x_min</code> and <code>x_max</code>. If the bounds are given as single values, they are applied for each dimension. If they are <code>Tuple</code>s of size <code>dim</code> the hypercube has the according bounds. If <code>dim</code> is not given explicitly, it is inferred by the lengths of <code>x_min</code> and <code>x_max</code> if possible. Optionally, pass a random number generator <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L225-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.random_hypercube_boundary" href="#KernelInterpolation.random_hypercube_boundary"><code>KernelInterpolation.random_hypercube_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_hypercube_boundary([rng], n, x_min = ntuple(_ -&gt; 0.0, dim), x_max = ntuple(_ -&gt; 1.0, dim); [dim])</code></pre><p>Create a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> with <code>n</code> random nodes each of dimension <code>dim</code> on the boundary of a hypercube defined by the bounds <code>x_min</code> and <code>x_max</code>. If the bounds are given as single values, they are applied for each dimension. If they are <code>Tuple</code>s of size <code>dim</code> the hypercube has the according bounds. If <code>dim</code> is not given explicitly, it is inferred by the lengths of <code>x_min</code> and <code>x_max</code> if possible. Optionally, pass a random number generator <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L255-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.random_hypersphere" href="#KernelInterpolation.random_hypersphere"><code>KernelInterpolation.random_hypersphere</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_hypersphere([rng], n, r = 1.0, center = Tuple(zeros(dim)); [dim])</code></pre><p>Create a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> with <code>n</code> random nodes each of dimension <code>dim</code> inside a hypersphere with radius <code>r</code> around the center <code>center</code>, which is given as a tuple. If <code>dim</code> is not given explicitly, it is inferred by the length of <code>center</code> if possible. Optionally, pass a random number generator <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L426-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.random_hypersphere_boundary" href="#KernelInterpolation.random_hypersphere_boundary"><code>KernelInterpolation.random_hypersphere_boundary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_hypersphere_boundary([rng], n, r = 1.0, center = Tuple(zeros(dim)); [dim])</code></pre><p>Create a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> with <code>n</code> random nodes each of dimension <code>dim</code> at the boundary of a hypersphere with radius <code>r</code> around the center <code>center</code>, which is given as a tuple. If <code>dim</code> is not given explicitly, it is inferred by the length of <code>center</code> if possible. Optionally, pass a random number generator <code>rng</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L459-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.separation_distance-Tuple{NodeSet}" href="#KernelInterpolation.separation_distance-Tuple{NodeSet}"><code>KernelInterpolation.separation_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">separation_distance(nodeset::NodeSet)</code></pre><p>Return the separation distance of a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> <span>$X = \{x_1,\ldots, x_n\}$</span> defined by</p><p class="math-container">\[    q_X = \frac{1}{2}\min_{x_i\neq x_j}\|x_i - x_j\|.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.values_along_dim-Tuple{NodeSet, Int64}" href="#KernelInterpolation.values_along_dim-Tuple{NodeSet, Int64}"><code>KernelInterpolation.values_along_dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">values_along_dim(nodeset::NodeSet, i::Int)</code></pre><p>Convenience function to return all <span>$x_i$</span>-values of the nodes, i.e. the <code>i</code>-th component of each node. Supported for <code>nodeset</code> with <code>dim(nodeset) &gt;= i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/nodes.jl#L209-L214">source</a></section></article><h2 id="Bases"><a class="docs-heading-anchor" href="#Bases">Bases</a><a id="Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Bases" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.AbstractBasis" href="#KernelInterpolation.AbstractBasis"><code>KernelInterpolation.AbstractBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractBasis</code></pre><p>Abstract type for a basis of a kernel function space. Every basis represents a set of functions, which can be obtained by indexing the basis object. Every basis object holds a kernel function and a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> of centers and potentially more fields depending on the concrete basis type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/basis.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.LagrangeBasis" href="#KernelInterpolation.LagrangeBasis"><code>KernelInterpolation.LagrangeBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LagrangeBasis(centers, kernel, m = order(kernel))</code></pre><p>The Lagrange (or cardinal) basis with respect to a kernel and a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> of <code>centers</code>. This basis already includes polynomial augmentation of degree <code>m</code> defaulting to <code>order(kernel)</code>. The basis functions are given such that</p><p class="math-container">\[    b_j(x_i) = \delta_{ij},\]</p><p>which means that the <a href="#KernelInterpolation.kernel_matrix"><code>kernel_matrix</code></a> of this basis is the identity matrix making it suitable if multiple interpolations with the same <code>centers</code> of the basis and the same <code>kernel</code>, but with different right-hand sides or nodesets are performed. Since the basis already includes polynomials no additional polynomial augmentation is needed for interpolation with this basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/basis.jl#L75-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.StandardBasis" href="#KernelInterpolation.StandardBasis"><code>KernelInterpolation.StandardBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StandardBasis(centers, kernel)</code></pre><p>The standard basis for a function space defined by a kernel and a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> of <code>centers</code>. The basis functions are given by</p><p class="math-container">\[    b_j(x) = K(x, x_j)\]</p><p>where <code>K</code> is the kernel and <code>x_j</code> are the nodes in <code>centers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/basis.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.centers-Tuple{KernelInterpolation.AbstractBasis}" href="#KernelInterpolation.centers-Tuple{KernelInterpolation.AbstractBasis}"><code>KernelInterpolation.centers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centers(basis)</code></pre><p>Return the centers from a basis object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/basis.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.interpolation_kernel-Tuple{KernelInterpolation.AbstractBasis}" href="#KernelInterpolation.interpolation_kernel-Tuple{KernelInterpolation.AbstractBasis}"><code>KernelInterpolation.interpolation_kernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_kernel(basis)</code></pre><p>Return the kernel from a basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/basis.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.order-Tuple{KernelInterpolation.AbstractBasis}" href="#KernelInterpolation.order-Tuple{KernelInterpolation.AbstractBasis}"><code>KernelInterpolation.order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(basis)</code></pre><p>Return the order <span>$m$</span> of the polynomial, which is needed by this <code>basis</code> for the interpolation, i.e., the polynomial degree plus 1. If <span>$m = 0$</span>, no polynomial is added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/basis.jl#L29-L35">source</a></section></article><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Interpolation" href="#KernelInterpolation.Interpolation"><code>KernelInterpolation.Interpolation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Interpolation</code></pre><p>Interpolation object that can be evaluated at a node and represents a kernel interpolation of the form</p><p class="math-container">\[    s(x) = \sum_{j = 1}^N c_jb_j(x) + \sum_{k = 1}^Q d_kp_k(x),\]</p><p>where <span>$b_j$</span> are the basis functions and <span>$p_k$</span> is a basis of the <code>Q</code>-dimensional space of multivariate polynomials of order <a href="#KernelInterpolation.order"><code>order</code></a>. The additional conditions</p><p class="math-container">\[    \sum_{j = 1}^N c_jp_k(x_j) = 0, \quad k = 1,\ldots, Q\]</p><p>are enforced.</p><p>See also <a href="#KernelInterpolation.interpolate-Union{Tuple{RealT}, Tuple{Dim}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}, NodeSet{Dim, RealT}}} where {Dim, RealT}"><code>interpolate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.TemporalInterpolation" href="#KernelInterpolation.TemporalInterpolation"><code>KernelInterpolation.TemporalInterpolation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TemporalInterpolation(ode_sol::ODESolution)</code></pre><p>Temporal interpolation of an ODE solution. The result can be evaluated at a time <code>t</code> and a spatial point <code>x</code>. Evaluating the interpolation at a time <code>t</code> returns an <a href="#Interpolation"><code>Interpolation</code></a> object that can be evaluated at a spatial point <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L286-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.basis-Tuple{Interpolation}" href="#KernelInterpolation.basis-Tuple{Interpolation}"><code>KernelInterpolation.basis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basis(itp)</code></pre><p>Return the basis from an interpolation object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.centers-Tuple{Interpolation}" href="#KernelInterpolation.centers-Tuple{Interpolation}"><code>KernelInterpolation.centers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centers(itp::Interpolation)</code></pre><p>Return the centers from the basis of an interpolation object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.coefficients-Tuple{Interpolation}" href="#KernelInterpolation.coefficients-Tuple{Interpolation}"><code>KernelInterpolation.coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coefficients(itp::Interpolation)</code></pre><p>Obtain all the coefficients of the linear combination for the interpolant, i.e., both the coefficients for the kernel part and for the polynomial part.</p><p>See also <a href="#KernelInterpolation.kernel_coefficients-Tuple{Interpolation}"><code>kernel_coefficients</code></a> and <a href="#KernelInterpolation.polynomial_coefficients-Tuple{Interpolation}"><code>polynomial_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L67-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.dim-Union{Tuple{Interpolation{Basis, Dim}}, Tuple{Dim}, Tuple{Basis}} where {Basis, Dim}" href="#KernelInterpolation.dim-Union{Tuple{Interpolation{Basis, Dim}}, Tuple{Dim}, Tuple{Basis}} where {Basis, Dim}"><code>KernelInterpolation.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(itp::Interpolation)</code></pre><p>Return the dimension of the input variables of the interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.interpolate-Union{Tuple{RealT}, Tuple{Dim}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}, NodeSet{Dim, RealT}}} where {Dim, RealT}" href="#KernelInterpolation.interpolate-Union{Tuple{RealT}, Tuple{Dim}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}}, Tuple{KernelInterpolation.AbstractBasis, Vector{RealT}, NodeSet{Dim, RealT}}} where {Dim, RealT}"><code>KernelInterpolation.interpolate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate(basis, values, nodeset = centers(basis); m = order(basis),
            regularization = NoRegularization())
interpolate(centers, [nodeset,] values, kernel = GaussKernel{dim(nodeset)}();
            m = order(kernel), regularization = NoRegularization())</code></pre><p>Interpolate the <code>values</code> evaluated at the nodes in the <code>nodeset</code> to a function using the kernel <code>kernel</code> and polynomials up to a order <code>m</code> (i.e. degree - 1), i.e., determine the coefficients <span>$c_j$</span> and <span>$d_k$</span> in the expansion</p><p class="math-container">\[    s(x) = \sum_{j = 1}^N c_jb_j(x) + \sum_{k = 1}^Q d_kp_k(x),\]</p><p>where <span>$b_j$</span> are the basis functions in the <code>basis</code> and <span>$s(x)$</span> the interpolant <span>$s(x_j) = f(x_j)$</span>, where <span>$f(x_j)$</span> are given by <code>values</code>, <span>$x_j$</span> are the nodes in the <code>nodeset</code>, and <span>$p_k$</span> is a basis of the <span>$Q$</span>-dimensional space of multivariate polynomials with maximum degree of <code>m - 1</code>. If <code>m = 0</code>, no polynomial is added. The additional conditions</p><p class="math-container">\[    \sum_{j = 1}^N c_jp_k(x_j) = 0, \quad k = 1,\ldots, Q = \begin{pmatrix}m - 1 + d\\d\end{pmatrix}\]</p><p>are enforced. Returns an <a href="#Interpolation"><code>Interpolation</code></a> object.</p><p>If <code>nodeset</code> is provided, the interpolant is a least squares approximation with a different set of nodes as the centers used for the basis. Otherwise, <code>nodeset</code> is set to <code>centers(basis)</code> or <code>centers</code>.</p><p>A regularization can be applied to the kernel matrix using the <code>regularization</code> argument, cf. <a href="#KernelInterpolation.regularize!"><code>regularize!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L135-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.interpolation_kernel-Tuple{KernelInterpolation.AbstractInterpolation}" href="#KernelInterpolation.interpolation_kernel-Tuple{KernelInterpolation.AbstractInterpolation}"><code>KernelInterpolation.interpolation_kernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_kernel(itp)</code></pre><p>Return the kernel from an interpolation object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.kernel_coefficients-Tuple{Interpolation}" href="#KernelInterpolation.kernel_coefficients-Tuple{Interpolation}"><code>KernelInterpolation.kernel_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kernel_coefficients(itp::Interpolation)</code></pre><p>Obtain the coefficients of the kernel part of the linear combination for the interpolant.</p><p>See also <a href="#KernelInterpolation.coefficients-Tuple{Interpolation}"><code>coefficients</code></a> and <a href="#KernelInterpolation.polynomial_coefficients-Tuple{Interpolation}"><code>polynomial_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.kernel_inner_product-Tuple{Any, Any}" href="#KernelInterpolation.kernel_inner_product-Tuple{Any, Any}"><code>KernelInterpolation.kernel_inner_product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kernel_inner_product(itp1, itp2)</code></pre><p>Inner product of the native space for two interpolants <code>itp1</code> and <code>itp2</code> with the same kernel. The inner product is defined as</p><p class="math-container">\[    \langle f, g\rangle_K = \sum_{i = 1}^N\sum_{j = 1}^Mc_i^fc_j^gK(x_i, \xi_j)\]</p><p>for the interpolants <span>$f(x) = \sum_{i = 1}^Nc_i^fK(x, x_i)$</span> and <span>$g(x) = \sum_{j = 1}^Mc_j^gK(x, \xi_j)$</span>.</p><p>See also <a href="#KernelInterpolation.kernel_norm-Tuple{Any}"><code>kernel_norm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L243-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.kernel_norm-Tuple{Any}" href="#KernelInterpolation.kernel_norm-Tuple{Any}"><code>KernelInterpolation.kernel_norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kernel_norm(itp)</code></pre><p>Norm of the native space defined by the kernel of the interpolant <code>itp</code>. The norm is defined as</p><p class="math-container">\[    \|f\|_K^2 = \sum_{i,j=1}^Nc_ic_jK(x_i, x_j)\]</p><p>for the interpolant <span>$f(x) = \sum_{j = 1}^nc_jK(x, x_j)$</span>.</p><p>See also <a href="#KernelInterpolation.kernel_inner_product-Tuple{Any, Any}"><code>kernel_inner_product</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L272-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.nodeset-Tuple{KernelInterpolation.AbstractInterpolation}" href="#KernelInterpolation.nodeset-Tuple{KernelInterpolation.AbstractInterpolation}"><code>KernelInterpolation.nodeset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodeset(itp)</code></pre><p>Return the node set from an interpolation object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.order-Tuple{Interpolation}" href="#KernelInterpolation.order-Tuple{Interpolation}"><code>KernelInterpolation.order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(itp)</code></pre><p>Return the order <span>$m$</span> of the polynomial used for the interpolation, i.e., the polynomial degree plus 1. If <span>$m = 0$</span>, no polynomial is added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.polynomial_basis-Tuple{Interpolation}" href="#KernelInterpolation.polynomial_basis-Tuple{Interpolation}"><code>KernelInterpolation.polynomial_basis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_basis(itp::Interpolation)</code></pre><p>Return a vector of the polynomial basis functions used for the interpolation.</p><p>See also <a href="#KernelInterpolation.polyvars-Tuple{Interpolation}"><code>polyvars</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.polynomial_coefficients-Tuple{Interpolation}" href="#KernelInterpolation.polynomial_coefficients-Tuple{Interpolation}"><code>KernelInterpolation.polynomial_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_coefficients(itp::Interpolation)</code></pre><p>Obtain the coefficients of the polynomial part of the linear combination for the interpolant.</p><p>See also <a href="#KernelInterpolation.coefficients-Tuple{Interpolation}"><code>coefficients</code></a> and <a href="#KernelInterpolation.kernel_coefficients-Tuple{Interpolation}"><code>kernel_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.polyvars-Tuple{Interpolation}" href="#KernelInterpolation.polyvars-Tuple{Interpolation}"><code>KernelInterpolation.polyvars</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polyvars(itp::Interpolation)</code></pre><p>Return a vector of the polynomial variables.</p><p>See also <a href="#KernelInterpolation.polynomial_basis-Tuple{Interpolation}"><code>polynomial_basis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.system_matrix-Tuple{Interpolation}" href="#KernelInterpolation.system_matrix-Tuple{Interpolation}"><code>KernelInterpolation.system_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">system_matrix(itp::Interpolation)</code></pre><p>Return the system matrix, i.e., the matrix <span>$A$</span> in the linear system</p><p class="math-container">\[    Ac = f,\]</p><p>where <span>$c$</span> are the coefficients of the kernel interpolant and <span>$f$</span> the vector of known values. The exact form of <span>$A$</span> differs depending on which method is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/interpolation.jl#L123-L132">source</a></section></article><h2 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.AbstractRegularization" href="#KernelInterpolation.AbstractRegularization"><code>KernelInterpolation.AbstractRegularization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRegularization</code></pre><p>An abstract supertype of regularizations. A regularization implements a function <a href="#KernelInterpolation.regularize!"><code>regularize!</code></a> that takes a matrix and returns a regularized version of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/regularization.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.L2Regularization" href="#KernelInterpolation.L2Regularization"><code>KernelInterpolation.L2Regularization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">L2Regularization(regularization_parameter::Real)</code></pre><p>A regularization that adds a multiple of the identity matrix to the input matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/regularization.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.NoRegularization" href="#KernelInterpolation.NoRegularization"><code>KernelInterpolation.NoRegularization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoRegularization()</code></pre><p>A regularization that does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/regularization.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.regularize!" href="#KernelInterpolation.regularize!"><code>KernelInterpolation.regularize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularize!(A, reg::AbstractRegularization)</code></pre><p>Apply the regularization <code>reg</code> to the matrix <code>A</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/regularization.jl#L9-L13">source</a></section></article><h2 id="api-diffops"><a class="docs-heading-anchor" href="#api-diffops">Differential Operators</a><a id="api-diffops-1"></a><a class="docs-heading-anchor-permalink" href="#api-diffops" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.EllipticOperator" href="#KernelInterpolation.EllipticOperator"><code>KernelInterpolation.EllipticOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EllipticOperator(A, b, c)</code></pre><p>Linear second-order elliptic operator with matrix <span>$A(x)\in\mathbb{R}^{d\times d}$</span>, vector <span>$b(x)\in\mathbb{R}^d$</span>, and scalar <span>$c(x)$</span>. The operator is defined as</p><p class="math-container">\[    \mathcal{L}u = -\sum_{i,j = 1}^d a_{ij}(x)\partial_{x_i,x_j}^2u + \sum_{i = 1}^db_i(x)\partial_{x_i}u + c(x)u.\]</p><p><code>A</code>, <code>b</code> and <code>c</code> are space-dependent functions returning a matrix, a vector, and a scalar, respectively. The matrix <code>A</code> should be symmetric and positive definite for any input <code>x</code>. The operator can be called with a <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a> and points <code>x</code> and <code>y</code> to evaluate the operator of the <code>kernel</code> at <code>x - y</code>. It can also be called with an <a href="#Interpolation"><code>Interpolation</code></a> object and a point <code>x</code> to evaluate the elliptic operator of the interpolation at <code>x</code>. Note that this is only supported for the kernel part of the interpolation, i.e. the polynomial part, if existent, is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/differential_operators.jl#L82-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Gradient" href="#KernelInterpolation.Gradient"><code>KernelInterpolation.Gradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient()</code></pre><p>The gradient operator. It can be called with a <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a> and points <code>x</code> and <code>y</code> to evaluate the gradient of the <code>kernel</code> at <code>x - y</code>. It can also be called with an <a href="#Interpolation"><code>Interpolation</code></a> object and a point <code>x</code> to evaluate the gradient of the interpolation at <code>x</code>. Note that this is only supported for the kernel part of the interpolation, i.e. the polynomial part, if existent, is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/differential_operators.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Laplacian" href="#KernelInterpolation.Laplacian"><code>KernelInterpolation.Laplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laplacian()</code></pre><p>The Laplacian operator. It can be called with a <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a> and points <code>x</code> and <code>y</code> to evaluate the Laplacian of the <code>kernel</code> at <code>x - y</code>. It can also be called with an <a href="#Interpolation"><code>Interpolation</code></a> object and a point <code>x</code> to evaluate the Laplacian of the interpolation at <code>x</code>. Note that this is only supported for the kernel part of the interpolation, i.e. the polynomial part, if existent, is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/differential_operators.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.PartialDerivative" href="#KernelInterpolation.PartialDerivative"><code>KernelInterpolation.PartialDerivative</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PartialDerivative(i)</code></pre><p>Partial derivative operator with respect to the <code>i</code>-th component. The operator can be called with a <a href="#KernelInterpolation.RadialSymmetricKernel"><code>RadialSymmetricKernel</code></a> and points <code>x</code> and <code>y</code> to evaluate the derivative of the <code>kernel</code> at <code>x - y</code>. It can also be called with an <a href="#Interpolation"><code>Interpolation</code></a> object and a point <code>x</code> to evaluate the first partial derivative of the interpolation at <code>x</code> in the <code>i</code>-th direction. Note that this is only supported for the kernel part of the interpolation, i.e. the polynomial part, if existent, is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/differential_operators.jl#L19-L28">source</a></section></article><h2 id="api-equations"><a class="docs-heading-anchor" href="#api-equations">Partial differential equations</a><a id="api-equations-1"></a><a class="docs-heading-anchor-permalink" href="#api-equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.AdvectionDiffusionEquation" href="#KernelInterpolation.AdvectionDiffusionEquation"><code>KernelInterpolation.AdvectionDiffusionEquation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvectionDiffusionEquation(diffusivity, advection_velocity, f)</code></pre><p>Advection-diffusion equation with diffusivity <code>diffusivity</code> and advection velocity <code>advection_velocity</code>. The advection-diffusion equation is defined as</p><p class="math-container">\[    \partial_t u + \mathbf{a}\cdot\nabla u = \kappa\Delta u + f,\]</p><p>where <span>$\mathbf{a}$</span> is the advection velocity, <span>$\kappa$</span> is the diffusivity, and <span>$f$</span> is the right-hand side, which can be a time- and space-dependent function or a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/equations.jl#L138-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.AdvectionEquation" href="#KernelInterpolation.AdvectionEquation"><code>KernelInterpolation.AdvectionEquation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvectionEquation(advection_velocity)</code></pre><p>Advection equation with advection velocity <code>advection_velocity</code>. The advection equation is defined as</p><p class="math-container">\[    \partial_t u + \mathbf{a}\cdot\nabla u = f,\]</p><p>where <span>$\mathbf{a}$</span> is the advection velocity and <span>$f$</span> a source term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/equations.jl#L82-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.EllipticEquation" href="#KernelInterpolation.EllipticEquation"><code>KernelInterpolation.EllipticEquation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EllipticEquation(A, b, c, f)</code></pre><p>Libear second-order elliptic equation with matrix <code>A</code>, vector <code>b</code>, and scalar <code>c</code> and right-hand side <code>f</code>. The elliptic equation is defined as</p><p class="math-container">\[    \mathcal{L}u = -\sum_{i,j = 1}^d a_{ij}(x)\partial_{x_i,x_j}^2u + \sum_{i = 1}^db_i(x)\partial_{x_i}u + c(x)u = f,\]</p><p>where <code>A</code>, <code>b</code> and <code>c</code> are space-dependent functions returning a matrix, a vector, and a scalar, respectively.</p><p>See also <a href="#KernelInterpolation.EllipticOperator"><code>EllipticOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/equations.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.HeatEquation" href="#KernelInterpolation.HeatEquation"><code>KernelInterpolation.HeatEquation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HeatEquation(diffusivity, f)</code></pre><p>Heat equation with thermal diffusivity <code>diffusivity</code>. The heat equation is defined as</p><p class="math-container">\[    \partial_t u = \kappa\Delta u + f,\]</p><p>where <span>$\kappa$</span> is the thermal diffusivity and <span>$f$</span> is the right-hand side, which can be a time- and space-dependent function or a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/equations.jl#L112-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.PoissonEquation" href="#KernelInterpolation.PoissonEquation"><code>KernelInterpolation.PoissonEquation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonEquation(f)</code></pre><p>Poisson equation with right-hand side <code>f</code>, which can be a space-dependent function or a vector. The Poisson equation is defined as</p><p class="math-container">\[    -\Delta u = f\]</p><p>See also <a href="#KernelInterpolation.Laplacian"><code>Laplacian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/equations.jl#L13-L23">source</a></section></article><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.Semidiscretization" href="#KernelInterpolation.Semidiscretization"><code>KernelInterpolation.Semidiscretization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Semidiscretization(spatial_discretization, initial_condition)
Semidiscretization(equations, nodeset_inner, boundary_condition, nodeset_boundary, [centers,]
                   initial_condition, kernel = GaussKernel{dim(nodeset_inner)}())</code></pre><p>Semidiscretization of a partial differential equation with Dirichlet boundary conditions and initial condition <code>initial_condition</code>. The <code>boundary_condition</code> function can be time- and space-dependent. The <code>initial_condition</code> function is time- and space-dependent to be able to reuse it as analytical solution if available. If no analytical solution is available, the time variable can be ignored in the <code>initial_condition</code> function. The <code>centers</code> are the centers of the kernel functions. By default, <code>centers</code> is set to <code>merge(nodeset_inner, nodeset_boundary)</code>. Note that <code>centers</code> needs to have the center number of nodes as the number of nodes in the domain and on the boundary because OrdinaryDiffEq.jl does not support DAEs with rectangular mass matrices.</p><p>See also <a href="#KernelInterpolation.SpatialDiscretization"><code>SpatialDiscretization</code></a>, <a href="#KernelInterpolation.semidiscretize-Tuple{Semidiscretization, Any}"><code>semidiscretize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/discretization.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.SpatialDiscretization" href="#KernelInterpolation.SpatialDiscretization"><code>KernelInterpolation.SpatialDiscretization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpatialDiscretization(equations, nodeset_inner, boundary_condition, nodeset_boundary, basis)
SpatialDiscretization(equations, nodeset_inner, boundary_condition, nodeset_boundary,
                      [centers,] kernel = GaussKernel{dim(nodeset_inner)}())</code></pre><p>Spatial discretization of a partial differential equation with Dirichlet boundary conditions. The <code>nodeset_inner</code> are the nodes in the domain and <code>nodeset_boundary</code> are the nodes on the boundary. The <code>boundary_condition</code> is a function describing the Dirichlet boundary conditions. The <code>centers</code> are the centers of the kernel functions. By default, <code>centers</code> is set to <code>merge(nodeset_inner, nodeset_boundary)</code>. Otherwise, a least squares problem is solved.</p><p>See also <a href="#KernelInterpolation.Semidiscretization"><code>Semidiscretization</code></a>, <a href="#KernelInterpolation.solve_stationary-Union{Tuple{SpatialDiscretization{Dim, RealT}}, Tuple{RealT}, Tuple{Dim}} where {Dim, RealT}"><code>solve_stationary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/discretization.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.semidiscretize-Tuple{Semidiscretization, Any}" href="#KernelInterpolation.semidiscretize-Tuple{Semidiscretization, Any}"><code>KernelInterpolation.semidiscretize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">semidiscetize(semi::Semidiscretization, tspan)</code></pre><p>Wrap a <a href="#KernelInterpolation.Semidiscretization"><code>Semidiscretization</code></a> object into an <code>ODEProblem</code> object with time span <code>tspan</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/discretization.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.solve_stationary-Union{Tuple{SpatialDiscretization{Dim, RealT}}, Tuple{RealT}, Tuple{Dim}} where {Dim, RealT}" href="#KernelInterpolation.solve_stationary-Union{Tuple{SpatialDiscretization{Dim, RealT}}, Tuple{RealT}, Tuple{Dim}} where {Dim, RealT}"><code>KernelInterpolation.solve_stationary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_stationary(spatial_discretization)</code></pre><p>Solve a stationary partial differential equation discretized as <code>spatial_discretization</code> with Dirichlet boundary conditions by non-symmetric collocation (Kansa method). Returns an <a href="#Interpolation"><code>Interpolation</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/discretization.jl#L64-L70">source</a></section></article><h2 id="Kernel-matrices"><a class="docs-heading-anchor" href="#Kernel-matrices">Kernel matrices</a><a id="Kernel-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.interpolation_matrix" href="#KernelInterpolation.interpolation_matrix"><code>KernelInterpolation.interpolation_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_matrix(centers, kernel, ps, regularization = NoRegularization())
interpolation_matrix(basis, ps, regularization)</code></pre><p>Return the interpolation matrix for the <code>basis</code>, polynomials <code>ps</code>, and <code>regularization</code>. For the <a href="#KernelInterpolation.StandardBasis"><code>StandardBasis</code></a>, the interpolation matrix is defined as</p><p class="math-container">\[    A = \begin{pmatrix}K &amp; P\\P^T &amp; 0\end{pmatrix},\]</p><p>where <span>$K$</span> is the <a href="#KernelInterpolation.regularize!"><code>regularize!</code></a>d <a href="#KernelInterpolation.kernel_matrix"><code>kernel_matrix</code></a> and <span>$P$</span> the <a href="#KernelInterpolation.polynomial_matrix-Tuple{NodeSet, Any}"><code>polynomial_matrix</code></a>. If a node set of <code>centers</code> and a <code>kernel</code> are given, the interpolation matrix is computed for the <a href="#KernelInterpolation.StandardBasis"><code>StandardBasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.kernel_matrix" href="#KernelInterpolation.kernel_matrix"><code>KernelInterpolation.kernel_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kernel_matrix(basis, nodeset = centers(basis))
kernel_matrix(nodeset1[, nodeset2], kernel)</code></pre><p>Return the kernel matrix for the <code>nodes</code> and <code>kernel</code>. The kernel matrix is defined as</p><p class="math-container">\[    A_{ij} = b_j(x_i),\]</p><p>where <span>$b_i$</span> are the basis function in the <code>basis</code> and <code>x_i</code> are the nodes in the <code>nodeset</code>. If two nodesets and a <code>kernel</code> are given, the kernel matrix is computed for the <a href="#KernelInterpolation.StandardBasis"><code>StandardBasis</code></a> meaning</p><p class="math-container">\[    A_{ij} = K(\xi_j, x_i),\]</p><p>where <span>$\xi_j$</span> are the nodes/centers in <code>nodeset1</code>, <span>$x_i$</span> are the nodes in <code>nodeset2</code>, and <code>K</code> is the <code>kernel</code>. If <code>nodeset2</code> is not given, it defaults to <code>nodeset1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.least_squares_matrix" href="#KernelInterpolation.least_squares_matrix"><code>KernelInterpolation.least_squares_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">least_squares_matrix(basis, nodeset, ps, regularization = NoRegularization())
least_squares_matrix(centers, nodeset, kernel, ps, regularization = NoRegularization())</code></pre><p>Return the least squares matrix for the <code>basis</code>, <code>nodeset</code>, polynomials <code>ps</code>, and <code>regularization</code>. For the <a href="#KernelInterpolation.StandardBasis"><code>StandardBasis</code></a>, the least squares matrix is defined as</p><p class="math-container">\[    A = \begin{pmatrix}K &amp; P_1\\P_2^T &amp; 0\end{pmatrix},\]</p><p>where <span>$K$</span> is the <a href="#KernelInterpolation.regularize!"><code>regularize!</code></a>d <a href="#KernelInterpolation.kernel_matrix"><code>kernel_matrix</code></a>, <span>$P_1$</span> the <a href="#KernelInterpolation.polynomial_matrix-Tuple{NodeSet, Any}"><code>polynomial_matrix</code></a> for the <code>nodeset</code> and <span>$P_2$</span> the <a href="#KernelInterpolation.polynomial_matrix-Tuple{NodeSet, Any}"><code>polynomial_matrix</code></a><code>for the</code>centers<code>. If a</code>nodeset<code>and</code>kernel<code>are given, the least squares matrix is computed for the [</code>StandardBasis`](@ref).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.operator_matrix-NTuple{4, Any}" href="#KernelInterpolation.operator_matrix-NTuple{4, Any}"><code>KernelInterpolation.operator_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">operator_matrix(diff_op_or_pde, nodeset_inner, nodeset_boundary, kernel)</code></pre><p>Compute the operator matrix <span>$L$</span> discretizing <span>$\mathcal{L}$</span> for a given kernel. The operator matrix is defined as</p><p class="math-container">\[    L = A_\mathcal{L} A^{-1},\]</p><p>where <span>$A_\mathcal{L}$</span> is the matrix of the differential operator (defined by the <code>equations</code>), and <span>$A$</span> the kernel matrix.</p><p>See also <a href="#KernelInterpolation.pde_boundary_matrix-NTuple{5, Any}"><code>pde_boundary_matrix</code></a> and <a href="#KernelInterpolation.kernel_matrix"><code>kernel_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L198-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.pde_boundary_matrix-NTuple{5, Any}" href="#KernelInterpolation.pde_boundary_matrix-NTuple{5, Any}"><code>KernelInterpolation.pde_boundary_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pde_boundary_matrix(diff_op_or_pde, nodeset_inner, nodeset_boundary, [centers,] kernel)</code></pre><p>Compute the matrix of a partial differential equation (or differential operator) with a given kernel. The matrix is defined as</p><p class="math-container">\[    A_\mathcal{L} = \begin{pmatrix}\tilde A_\mathcal{L}\\\tilde A\end{pmatrix},\]</p><p>where <span>$\tilde A_\mathcal{L}$</span> is the matrix of the differential operator (defined by the <code>equations</code>) for the inner nodes <span>$x_i$</span>:</p><p class="math-container">\[    (\tilde A_\mathcal{L})_{ij} = \mathcal{L}K(x_i, \xi_j),\]</p><p>and <span>$\tilde A$</span> is the kernel matrix for the boundary nodes:</p><p class="math-container">\[    \tilde A_{ij} = K(x_i, \xi_j),\]</p><p>where <span>$\mathcal{L}$</span> is the differential operator (defined by the <code>equations</code>), <span>$K$</span> the <code>kernel</code>, <span>$x_i$</span> are the nodes in <code>nodeset_boundary</code> and <span>$\xi_j$</span> are the <code>centers</code>. By default, <code>centers</code> is set to <code>merge(nodeset_inner, nodeset_boundary)</code>.</p><p>See also <a href="#KernelInterpolation.pde_matrix-NTuple{4, Any}"><code>pde_matrix</code></a> and <a href="#KernelInterpolation.kernel_matrix"><code>kernel_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L165-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.pde_matrix-NTuple{4, Any}" href="#KernelInterpolation.pde_matrix-NTuple{4, Any}"><code>KernelInterpolation.pde_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pde_matrix(diff_op_or_pde, nodeset1, nodeset2, kernel)</code></pre><p>Compute the matrix of a partial differential equation (or differential operator) with a given kernel. The matrix is defined as</p><p class="math-container">\[    (\tilde A_\mathcal{L})_{ij} = \mathcal{L}K(x_i, \xi_j),\]</p><p>where <span>$\mathcal{L}$</span> is the differential operator (defined by the <code>equations</code>), <span>$K$</span> the <code>kernel</code>, <span>$x_i$</span> are the nodes in <code>nodeset1</code> and <span>$\xi_j$</span> are the nodes in <code>nodeset2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.polynomial_matrix-Tuple{NodeSet, Any}" href="#KernelInterpolation.polynomial_matrix-Tuple{NodeSet, Any}"><code>KernelInterpolation.polynomial_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_matrix(nodeset, ps)</code></pre><p>Return the polynomial matrix for the nodeset and polynomials. The polynomial matrix is defined as</p><p class="math-container">\[    A_{ij} = p_j(x_i),\]</p><p>where <span>$x_i$</span> are the nodes in the <code>nodeset</code> and <span>$p_j$</span> the polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/kernel_matrices.jl#L38-L46">source</a></section></article><h2 id="api-callbacks"><a class="docs-heading-anchor" href="#api-callbacks">Callbacks</a><a id="api-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#api-callbacks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.AliveCallback" href="#KernelInterpolation.AliveCallback"><code>KernelInterpolation.AliveCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AliveCallback(io::IO = stdout; interval::Integer=0, dt=nothing)</code></pre><p>Inexpensive callback showing that a simulation is still running by printing some information such as the current time to the screen every <code>interval</code> time steps or after a time of <code>dt</code> in terms of integration time by adding additional (shortened) time steps where necessary (note that this may change the solution).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/callbacks_step/alive.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.SummaryCallback" href="#KernelInterpolation.SummaryCallback"><code>KernelInterpolation.SummaryCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SummaryCallback(io::IO = stdout)</code></pre><p>Create and return a callback that resets the timer at the beginning of a simulation and prints the timer values at the end of the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/callbacks_step/summary.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.SaveSolutionCallback" href="#KernelInterpolation.SaveSolutionCallback"><code>KernelInterpolation.SaveSolutionCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SaveSolutionCallback(; interval::Integer=0,
                     dt=nothing,
                     save_initial_solution=true,
                     save_final_solution=true,
                     output_directory=&quot;out&quot;,
                     extra_functions=(),
                     keys=append!([&quot;itp&quot;], &quot;value_&quot; .* string.(eachindex(extra_functions))))</code></pre><p>Save the current numerical solution in regular intervals in VTK format as a Paraview Collection (.pvd). Either pass <code>interval</code> to save every <code>interval</code> time steps or pass <code>dt</code> to save in intervals of <code>dt</code> in terms of integration time by adding additional (shortened) time steps where necessary (note that this may change the solution). The interpolation object will always be saved at the inner and boundary nodes of the corresponding <a href="#KernelInterpolation.Semidiscretization"><code>Semidiscretization</code></a>. You can pass extra functions (time- and space-dependent) or vectors to save at these nodes via <code>extra_functions</code>. The corresponding keys in the <code>.vtu</code> files can be specified by <code>keys</code>.</p><p>See also <a href="#KernelInterpolation.add_to_pvd-Tuple{Any, Any, Any, NodeSet, Vararg{Any}}"><code>add_to_pvd</code></a>, <a href="#KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}"><code>vtk_save</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/callbacks_step/save_solution.jl#L4-L23">source</a></section></article><h2 id="Input/Output"><a class="docs-heading-anchor" href="#Input/Output">Input/Output</a><a id="Input/Output-1"></a><a class="docs-heading-anchor-permalink" href="#Input/Output" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.add_to_pvd-Tuple{Any, Any, Any, NodeSet, Vararg{Any}}" href="#KernelInterpolation.add_to_pvd-Tuple{Any, Any, Any, NodeSet, Vararg{Any}}"><code>KernelInterpolation.add_to_pvd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_to_pvd(filename, pvd, time, nodeset::NodeSet, functions_or_vectors...;
           keys = &quot;value_&quot; .* string.(eachindex(functions_or_vectors)))</code></pre><p>Same as <a href="#KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}"><code>vtk_save</code></a>, but appends the data to a Paraview collection file <code>pvd</code> at time <code>time</code>. In contrast to <a href="#KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}"><code>vtk_save</code></a>, the functions are time- and space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/io.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.vtk_read-Tuple{Any}" href="#KernelInterpolation.vtk_read-Tuple{Any}"><code>KernelInterpolation.vtk_read</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vtk_read(filename)</code></pre><p>Read a set of nodes from a VTK file and return them as a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a>. Note that the data will always be returned as a 3D <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a>, even if the data is 1D or 2D. The point data will be returned as a dictionary with the keys being the names of the data arrays in the VTK file.</p><p>See also <a href="#KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}"><code>vtk_save</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/io.jl#L54-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}" href="#KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}"><code>KernelInterpolation.vtk_save</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vtk_save(filename, nodeset::NodeSet, functions_or_vectors...;
         keys = &quot;value_&quot; .* string.(eachindex(functions_or_vectors)))</code></pre><p>Save a <a href="#KernelInterpolation.NodeSet"><code>NodeSet</code></a> to a VTK file. You can optionally pass a list of space-dependent functions or vectors to save the values of the functions at the nodes. The functions can also be passed as <a href="#Interpolation"><code>Interpolation</code></a> or directly as vectors. The optional keyword argument <code>keys</code> is used to specify the names of the data arrays in the VTK file.</p><p>See also <a href="#KernelInterpolation.add_to_pvd-Tuple{Any, Any, Any, NodeSet, Vararg{Any}}"><code>add_to_pvd</code></a>, <a href="#KernelInterpolation.vtk_read-Tuple{Any}"><code>vtk_read</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/io.jl#L1-L11">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.default_example-Tuple{}" href="#KernelInterpolation.default_example-Tuple{}"><code>KernelInterpolation.default_example</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_example()</code></pre><p>Return the path to an example that can be used to quickly see KernelInterpolation.jl in action. See also <a href="#KernelInterpolation.examples_dir-Tuple{}"><code>examples_dir</code></a> and <a href="#KernelInterpolation.get_examples-Tuple{}"><code>get_examples</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/util.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.examples_dir-Tuple{}" href="#KernelInterpolation.examples_dir-Tuple{}"><code>KernelInterpolation.examples_dir</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">examples_dir()</code></pre><p>Return the directory where the example files provided with KernelInterpolation.jl are located.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">readdir(examples_dir())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/util.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelInterpolation.get_examples-Tuple{}" href="#KernelInterpolation.get_examples-Tuple{}"><code>KernelInterpolation.get_examples</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_examples()</code></pre><p>Return a list of all examples that are provided by KernelInterpolation.jl. See also <a href="#KernelInterpolation.examples_dir-Tuple{}"><code>examples_dir</code></a> and <a href="#KernelInterpolation.default_example-Tuple{}"><code>default_example</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/eb877bc795d6561340d87ad7d5445cdb0dda4ad3/src/util.jl#L13-L18">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../development/">« Development</a><a class="docs-footer-nextpage" href="../changelog/">Changelog »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 22 May 2025 16:41">Thursday 22 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
