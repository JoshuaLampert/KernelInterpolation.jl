<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sets of nodes · KernelInterpolation.jl</title><meta name="title" content="Sets of nodes · KernelInterpolation.jl"/><meta property="og:title" content="Sets of nodes · KernelInterpolation.jl"/><meta property="twitter:title" content="Sets of nodes · KernelInterpolation.jl"/><meta name="description" content="Documentation for KernelInterpolation.jl."/><meta property="og:description" content="Documentation for KernelInterpolation.jl."/><meta property="twitter:description" content="Documentation for KernelInterpolation.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/nodesets/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/nodesets/"/><link rel="canonical" href="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/nodesets/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KernelInterpolation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li class="is-active"><a class="tocitem" href>Sets of nodes</a><ul class="internal"><li><a class="tocitem" href="#Visualizing-[NodeSet](@ref)s"><span>Visualizing <code>NodeSet</code>s</span></a></li></ul></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../pdes/">Solving PDEs by collocation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_differentiating_interpolation/">1D interpolation and differentiation</a></li></ul></li><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href>Sets of nodes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sets of nodes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/docs/src/nodesets.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="nodesets"><a class="docs-heading-anchor" href="#nodesets">Sets of nodes</a><a id="nodesets-1"></a><a class="docs-heading-anchor-permalink" href="#nodesets" title="Permalink"></a></h1><p>Numerical methods based on kernel functions are usually meshfree, i.e. they do not need not any information of connectivity between the different points (a mesh). Instead, they usually solely use a(n) (unstructured) set of points in space <span>$X = \{x_1, \ldots, x_N\}\subset\mathbb{R}^d$</span> with <span>$N$</span> nodes <span>$x_i$</span> of any dimension <span>$d\in\mathbb{N}$</span>. These vectors are also often called, e.g., <em>points</em>, <em>nodes</em>, <em>centers</em>, or <em>data sites</em> and sets of nodes are also sometimes called <em>point clouds</em>. Since meshes can sometimes be cumbersome to create and handle especially in higher space dimensions, kernel methods are often convenient and flexible for high-dimensional problems. In KernelInterpolation.jl, sets of points are called <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> and can be of any dimension. You can create <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s simply by passing a matrix, where the rows are the different points or by passing a <code>Vector</code> of <code>Vector</code>s:</p><pre><code class="language-julia hljs">using KernelInterpolation
nodes = NodeSet([0.0 0.0
                 0.0 1.0
                 1.0 0.0
                 1.0 1.0])
nodes2 = NodeSet([[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSet{2, Float64} with separation distance q = 0.5 and 4 nodes:
  [0.0, 0.0]
  [0.0, 1.0]
  [1.0, 0.0]
  [1.0, 1.0]
</code></pre><p>One characterization of how well distributed a set of nodes is, is the so-called <em>separation distance</em>, which is defined by</p><p class="math-container">\[q_X = \frac{1}{2}\min\limits_{x_i\neq x_j}\|x_i - x_j\|_2.\]</p><p>Geometrically, <span>$q_X$</span> is the radius of the largest ball that can be placed around every node in <span>$X$</span> such that no two balls overlap. This quantity depends only on the choice of the nodes and is always computed by KernelInterpolation.jl. It can be accessed by calling</p><pre><code class="language-julia hljs">q = separation_distance(nodes)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5</code></pre><p>The separation distance usually plays a crucial role when estimating the stability properties of kernel methods. Another important geometric property of node sets, often essential for the error analysis of kernel methods, is the so-called <em>fill distance</em> given by</p><p class="math-container">\[h_X = \sup_{x\in\Omega}\min_{x_j\in X}\|x - x_j\|_2,\]</p><p>which can be interpreted as the radius of the largest ball that can be placed in <span>$\Omega$</span> such that the ball does not contain any point in <span>$X$</span>. This quantity depends on the choice of a domain <span>$\Omega\subset\mathbb{R^d}$</span> that covers <span>$X$</span> and can therefore not solely be computed by the <code>NodeSet</code>. However, it can be estimated by creating a fine grid of points inside <span>$\Omega$</span>. Let&#39;s say we take <span>$\Omega = [0,1]^2$</span>. We can conveniently create a set of equidistant points within any hypercube by calling <a href="../ref/#KernelInterpolation.homogeneous_hypercube"><code>homogeneous_hypercube</code></a>:</p><pre><code class="language-julia hljs">nodes_fine = homogeneous_hypercube(20, (0.0, 0.0), (1.0, 1.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSet{2, Float64} with separation distance q = 0.02631578947368418 and 400 nodes:
  [0.0, 0.0]
  [0.05263157894736842, 0.0]
  [0.10526315789473684, 0.0]
  [0.15789473684210525, 0.0]
  [0.21052631578947367, 0.0]
  [0.2631578947368421, 0.0]
  [0.3157894736842105, 0.0]
  [0.3684210526315789, 0.0]
  [0.42105263157894735, 0.0]
  [0.47368421052631576, 0.0]
  [0.5263157894736842, 0.0]
  [0.5789473684210527, 0.0]
  [0.631578947368421, 0.0]
  [0.6842105263157895, 0.0]
  [0.7368421052631579, 0.0]
  [0.7894736842105263, 0.0]
  [0.8421052631578947, 0.0]
  [0.8947368421052632, 0.0]
  [0.9473684210526315, 0.0]
  [1.0, 0.0]
  ⋮
</code></pre><p>This creates a <code>NodeSet</code> with 20 nodes equally spaced along both dimensions. The distance matrix of the two sets, i.e. the matrix with entries <span>$D_{ij} = \|x_i - \xi_j\|_2$</span> for <span>$x_i\in X$</span> and <span>$\xi_j$</span> being the evaluation points in <span>$\Omega$</span>, can be obtained by calling the function <a href="../ref/#KernelInterpolation.distance_matrix-Tuple{NodeSet, NodeSet}"><code>distance_matrix</code></a>:</p><pre><code class="language-julia hljs">D = distance_matrix(nodes, nodes_fine)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×400 Matrix{Float64}:
 0.0      0.0526316  0.105263  0.157895  …  1.34185   1.3775     1.41421
 1.0      1.00138    1.00552   1.01239      0.894737  0.947368   1.0
 1.0      0.947368   0.894737  0.842105     1.00552   1.00138    1.0
 1.41421  1.3775     1.34185   1.30734      0.105263  0.0526316  0.0</code></pre><p>Finally, the fill distance is approximated by</p><pre><code class="language-julia hljs">h = maximum(minimum(D, dims = 1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.6698906348083082</code></pre><p>Note that this is only an estimate. The true fill distance is <span>$\sqrt{2}/2\approx 0.707$</span> (and reached by placing <span>$x\in\Omega$</span> at <span>$(0.5, 0.5)^T$</span>). The estimate can be improved by taking a finer evaluation grid.</p><p>Next to <a href="../ref/#KernelInterpolation.homogeneous_hypercube"><code>homogeneous_hypercube</code></a>, KernelInterpolation.jl provides additional convenience functions to create specific commonly used <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s. These are <a href="../ref/#KernelInterpolation.homogeneous_hypercube_boundary"><code>homogeneous_hypercube_boundary</code></a> to create equally spaced nodes at the boundary of a hypercube, <a href="../ref/#KernelInterpolation.random_hypercube"><code>random_hypercube</code></a> and <a href="../ref/#KernelInterpolation.random_hypercube_boundary"><code>random_hypercube_boundary</code></a> to create random uniformly distributed nodes inside or at the boundary of a hypercube, and <a href="../ref/#KernelInterpolation.random_hypersphere"><code>random_hypersphere</code></a> and <a href="../ref/#KernelInterpolation.random_hypersphere_boundary"><code>random_hypersphere_boundary</code></a> for random uniformly distributed nodes inside or at the boundary of a hypersphere. Note that the first argument <code>n</code> of the <code>homogeneous_*</code> functions denotes the number of points <strong>along each dimension</strong>, while for the <code>random_*</code> function it denotes the <strong>number of total generated nodes</strong>.</p><p>Other sampling methods for hypercubes of any dimension can be obtained by using the package <a href="https://docs.sciml.ai/QuasiMonteCarlo/stable/">QuasiMonteCarlo.jl</a>. We can simply pass the (transposed) result of any sampling algorithm from QuasiMonteCarlo.jl to the constructor of <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>. To create, e.g., 500 Halton points in a box bounded by <span>$[-1.0, -1.0, -1.0]$</span> and <span>$[2.0, 2.0, 2.0]$</span> we can run:</p><pre><code class="language-julia hljs">using QuasiMonteCarlo: sample, HaltonSample
nodes_matrix = sample(500, [-1.0, -1.0, -1.0], [2.0, 2.0, 2.0], HaltonSample())
nodes_halton = NodeSet(nodes_matrix&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSet{3, Float64} with separation distance q = 0.029226325908781006 and 500 nodes:
  [-0.997, -0.997, -0.997]
  [0.5030000000000001, 0.0029999999999998916, -0.397]
  [-0.247, 1.0030000000000001, 0.20300000000000007]
  [1.2530000000000001, -0.6636666666666666, 0.8030000000000004]
  [-0.622, 0.33633333333333315, 1.403]
  [0.8780000000000001, 1.3363333333333332, -0.877]
  [0.1280000000000001, -0.33033333333333337, -0.277]
  [1.6280000000000001, 0.6696666666666664, 0.3230000000000002]
  [-0.8095, 1.6696666666666666, 0.9230000000000005]
  [0.6905000000000001, -0.885888888888889, 1.5230000000000001]
  [-0.0595, 0.11411111111111105, -0.7569999999999999]
  [1.4405000000000001, 1.1141111111111113, -0.15700000000000003]
  [-0.4345, -0.5525555555555556, 0.44300000000000006]
  [1.0655000000000001, 0.4474444444444443, 1.0430000000000001]
  [0.3155000000000001, 1.4474444444444439, 1.6430000000000002]
  [1.8155000000000001, -0.2192222222222222, -0.6369999999999999]
  [-0.90325, 0.7807777777777778, -0.03699999999999981]
  [0.5967500000000001, 1.7807777777777773, 0.5630000000000002]
  [-0.15325, -0.7747777777777778, 1.1630000000000003]
  [1.3467500000000001, 0.225222222222222, 1.763]
  ⋮
</code></pre><p>For the available sampling algorithms in QuasiMonteCarlo.jl, see the <a href="https://docs.sciml.ai/QuasiMonteCarlo/stable/samplers/">overview in the documentation</a>.</p><p>Another possibility to create more advanced <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s is by using the package <a href="https://github.com/JuliaGeometry/Meshes.jl">Meshes.jl</a> and the sampling algorithms defined therein. For example, we can create a regularly sampled set of nodes on the surface of a sphere by running:</p><pre><code class="language-julia hljs">using Meshes: Meshes, Sphere, Point, RegularSampling
sphere = Sphere(Point(0.0, 0.0, 0.0), 1.0)
sampler = RegularSampling(20, 30)
points = Meshes.sample(sphere, sampler)
nodes = NodeSet(collect(points))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NodeSet{3, Float64} with separation distance q = 0.015579159045324071 and 602 nodes:
  [0.14904226617617444, 0.0, 0.9888308262251285]
  [0.2947551744109042, 0.0, 0.9555728057861408]
  [0.4338837391175581, 0.0, 0.9009688679024191]
  [0.563320058063622, 0.0, 0.8262387743159949]
  [0.6801727377709194, 0.0, 0.7330518718298263]
  [0.7818314824680298, 0.0, 0.6234898018587336]
  [0.8660254037844386, 0.0, 0.5]
  [0.9308737486442042, 0.0, 0.3653410243663951]
  [0.9749279121818236, 0.0, 0.22252093395631448]
  [0.9972037971811801, 0.0, 0.07473009358642434]
  [0.9972037971811801, 0.0, -0.07473009358642434]
  [0.9749279121818236, 0.0, -0.2225209339563143]
  [0.9308737486442042, 0.0, -0.3653410243663951]
  [0.8660254037844387, 0.0, -0.4999999999999999]
  [0.7818314824680298, 0.0, -0.6234898018587336]
  [0.6801727377709195, 0.0, -0.7330518718298262]
  [0.563320058063622, 0.0, -0.8262387743159949]
  [0.43388373911755823, 0.0, -0.900968867902419]
  [0.2947551744109042, 0.0, -0.9555728057861408]
  [0.1490422661761746, 0.0, -0.9888308262251285]
  ⋮
</code></pre><p>For more information on the available sampling algorithms in Meshes.jl, see the <a href="https://juliageometry.github.io/MeshesDocs/stable/algorithms/sampling/">documentation</a>. In the documentation of Meshes.jl, you can also find information on how to create more complex geometries like ellipsoids, tori, and many more. In general, a <code>PointSet</code> from Meshes.jl or a <code>Vector</code> of <code>Point</code>s can be directly passed to the constructor of a <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> and vice versa can a <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> be passed to the constructor of a <code>PointSet</code>.</p><p>More complicated <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s consisting of different shapes can be created, e.g., by <code>merge</code>ing different <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s.</p><h2 id="Visualizing-[NodeSet](@ref)s"><a class="docs-heading-anchor" href="#Visualizing-[NodeSet](@ref)s">Visualizing <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s</a><a id="Visualizing-[NodeSet](@ref)s-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-[NodeSet](@ref)s" title="Permalink"></a></h2><p>To visualize a <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>, there are currently two possibilities. The first one uses <a href="https://docs.juliaplots.org/stable/">Plots.jl</a>. After installing and loading Plots.jl, we can then simply call <code>plot</code> on any 1D, 2D, or 3D <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> to plot it.</p><pre><code class="language-julia hljs">using Plots
plot(nodes_halton)</code></pre><p><img src="../nodes_halton.png" alt="Halton nodes"/></p><p>You might want to consider using other plotting backends, e.g. <a href="https://github.com/JuliaPy/PyPlot.jl">PyPlot.jl</a> can be used by additionally calling <code>pyplot()</code> before <code>plot</code> in the above code snippet. Refer to the <a href="https://docs.juliaplots.org/stable/backends/">documentation of Plots.jl</a> for the different available backends. In order to color the nodes according to the values of a function (or an <a href="../ref/#Interpolation"><code>Interpolation</code></a>) at the nodes, you can additionally pass the vector of function values as keyword argument <code>zcolor</code> (note that you can treat a <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> as a usual array, e.g., broadcasting works with the common dot syntax).</p><pre><code class="language-julia hljs">f(x) = sinpi(x[1])
plot(nodes_halton, zcolor = f.(nodes_halton))</code></pre><p><img src="../nodes_halton_function.png" alt="Halton nodes with function values"/></p><p>For 1D or 2D <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s you can also pass a function (or, again, an object of <a href="../ref/#Interpolation"><code>Interpolation</code></a>), which is then used to determine the values in the vertical direction. For a surface plot of a function based on a set of nodes, you can, e.g., run the following</p><pre><code class="language-julia hljs">plot(nodes_fine, f, st = :surface)</code></pre><p><img src="../nodes_fine.png" alt="Surface plot"/></p><p>As an alternative to plotting from within Julia, you can save <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s to the commonly used <a href="https://vtk.org/">VTK files</a> and then view the result, e.g., in <a href="https://www.paraview.org/">ParaView</a> or <a href="https://visit-dav.github.io/visit-website/">VisIt</a>. You can save a <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> simply by using <a href="../ref/#KernelInterpolation.vtk_save-Tuple{Any, NodeSet, Vararg{Any}}"><code>vtk_save</code></a> and passing a filename as well as the <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>:</p><pre><code class="language-julia hljs">vtk_save(&quot;nodes_halton&quot;, nodes_halton)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{String}:
 &quot;nodes_halton.vtu&quot;</code></pre><p>Again, you can additionally save node values by passing additional functions or vectors (of the same size as the <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>), which can also be visualized with ParaView or VisIt. Note that you can also read back in a <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a> (and possibly the additional node values) by using <a href="../ref/#KernelInterpolation.vtk_read-Tuple{Any}"><code>vtk_read</code></a>:</p><pre><code class="language-julia hljs">nodes_halton2, _ = vtk_read(&quot;nodes_halton.vtu&quot;)
all(nodes_halton2 .== nodes_halton)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../interpolation/">Interpolation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 28 September 2024 11:46">Saturday 28 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
