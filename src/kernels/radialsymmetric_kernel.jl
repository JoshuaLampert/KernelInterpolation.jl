@doc raw"""
    RadialSymmetricKernel

An abstract supertype of radial symmetric kernels. Radial symmetric
kernels are generated by an even and continuous function
``\Phi: \mathbb{R}^d\to\mathbb{R}``, which is radial-symmetric meaning that
there exists a ``\phi:[0,\infty]\to\mathbb{R}`` such that
```math
    \Phi(x) = \phi(\Vert x\Vert).
```
The kernel is then defined by
```math
    K(x, y) = \Phi(x - y).
```

A `RadialSymmetricKernel` can be evaluated at two points `x` and `y` by calling
`kernel(x, y)` or at a single point `x` by calling `kernel(x)`, which implicitly
sets `y` to zero.
"""
abstract type RadialSymmetricKernel{Dim} <: AbstractKernel{Dim} end

@doc raw"""
    phi(kernel, r)

For a [`RadialSymmetricKernel`](@ref) `kernel` return value of the univariate function
``\phi`` defining the kernel.

See also [`RadialSymmetricKernel`](@ref), [`Phi`](@ref).
"""
function phi end

@doc raw"""
    Phi(kernel, x)

For a [`RadialSymmetricKernel`](@ref) `kernel` return value of the multivariate function
``\Phi`` defined by ``\Phi(x) = \phi(\Vert x\Vert)``.

See also [`RadialSymmetricKernel`](@ref), [`phi`](@ref).
"""
function Phi(kernel::RadialSymmetricKernel{Dim}, x) where {Dim}
    r = norm(x)
    return phi(kernel, r)
end

function (kernel::RadialSymmetricKernel)(x, y)
    @assert length(x)==length(y) "x and y must have the same length"
    return Phi(kernel, x .- y)
end

"""
    order(kernel)

Return order of kernel.
"""
function order end

@doc raw"""
    GaussKernel{Dim}(; shape_parameter = 1.0)

Gaussian kernel function with
```math
    \phi(r) = \exp(-(\varepsilon r)^2),
```
where ``\varepsilon`` is the shape parameter. The Gaussian kernel
is always positive definite.
See Wendland (2004), p. 74.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
"""
struct GaussKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    shape_parameter::RealT
end

function GaussKernel{Dim}(; shape_parameter = 1.0) where {Dim}
    GaussKernel{Dim, typeof(shape_parameter)}(shape_parameter)
end

function Base.show(io::IO, kernel::GaussKernel{Dim}) where {Dim}
    print(io, "GaussKernel{", Dim, "}(shape_parameter = ", kernel.shape_parameter, ")")
end

phi(kernel::GaussKernel, r::Real) = exp(-(kernel.shape_parameter * r)^2)
order(::GaussKernel) = 0

@doc raw"""
    MultiquadricKernel{Dim}(beta = 0.5; shape_parameter = 1.0)

Multiquadric kernel function with
```math
    \phi(r) = (1 + (\varepsilon r)^2)^\beta,
```
where ``\varepsilon`` is the shape parameter. The multiquadric kernel
is conditionally positive definite of order ``m = \lceil\beta \rceil``.
See Wendland (2004), p. 109.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
"""
struct MultiquadricKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    beta::RealT
    shape_parameter::RealT
end

function MultiquadricKernel{Dim}(beta = 0.5; shape_parameter = 1.0) where {Dim}
    MultiquadricKernel{Dim, typeof(shape_parameter)}(beta, shape_parameter)
end

function Base.show(io::IO, kernel::MultiquadricKernel{Dim}) where {Dim}
    print(io, "MultiquadricKernel{", Dim, "}(shape_parameter = ", kernel.shape_parameter,
          ")")
end

phi(kernel::MultiquadricKernel, r::Real) = (1 + (kernel.shape_parameter * r)^2)^kernel.beta
order(kernel::MultiquadricKernel) = ceil(kernel.beta)

@doc raw"""
    InverseMultiquadricKernel{Dim}(beta = 0.5; shape_parameter = 1.0)

Inverse multiquadric kernel function with
```math
    \phi(r) = (1 + (\varepsilon r)^2)^{-\beta},
```
where ``\varepsilon`` is the shape parameter. The inverse multiquadric kernel
is always positive definite.
See Wendland (2004), p. 76 and p. 95.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
"""
struct InverseMultiquadricKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    beta::RealT
    shape_parameter::RealT
end

function InverseMultiquadricKernel{Dim}(beta = 0.5; shape_parameter = 1.0) where {Dim}
    InverseMultiquadricKernel{Dim, typeof(shape_parameter)}(beta, shape_parameter)
end

function Base.show(io::IO, kernel::InverseMultiquadricKernel{Dim}) where {Dim}
    print(io, "InverseMultiquadricKernel{", Dim, "}(beta = ", kernel.beta,
          ", shape_parameter = ", kernel.shape_parameter, ")")
end

function phi(kernel::InverseMultiquadricKernel, r::Real)
    (1 + (kernel.shape_parameter * r)^2)^(-kernel.beta)
end
order(::InverseMultiquadricKernel) = 0

@doc raw"""
    PolyharmonicSplineKernel{Dim}(k)

Polyharmonic spline kernel function with
```math
    \phi_k(r) = \begin{cases}
        r^k, &\text{ if } k \text{ odd}\\
        r^k\log(r), &\text{ if } k \text{ even}
    \end{cases}.
```
The polyharmonic spline is conditionally positive definite of order ``m = \lceil k/2\rceil``
for odd `k` and order ``m = k/2 + 1`` for even `k`.
See Wendland (2004), pp. 111--112.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
"""
struct PolyharmonicSplineKernel{Dim} <: RadialSymmetricKernel{Dim}
    k::Int
end

function get_name(kernel::PolyharmonicSplineKernel)
    string(nameof(typeof(kernel))) * string(kernel.k) * "{" * string(dim(kernel)) * "}"
end

function Base.show(io::IO, kernel::PolyharmonicSplineKernel{Dim}) where {Dim}
    print(io, "PolyharmonicSplineKernel{", Dim, "}(k = ", kernel.k, ")")
end

function phi(kernel::PolyharmonicSplineKernel, r::Real)
    if isodd(kernel.k)
        return r^kernel.k
    else
        return isapprox(r, 0.0) ? 0.0 : r^kernel.k * log(r)
    end
end

function order(kernel::PolyharmonicSplineKernel)
    isodd(kernel.k) ? ceil(kernel.k / 2) : ceil(kernel.k / 2) + 1
end

@doc raw"""
    ThinPlateSplineKernel{Dim}()

Thin plate spline kernel function with
```math
    \phi(r) = r^2\log(r),
```
i.e., [`PolyharmonicSplineKernel`](@ref) with ``k = 2``.
The thin plate spline is conditionally positive definite of order ``m = 2``.
See Wendland (2004), p. 112.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
"""
struct ThinPlateSplineKernel{Dim} <: RadialSymmetricKernel{Dim} end

function Base.show(io::IO, kernel::ThinPlateSplineKernel{Dim}) where {Dim}
    print(io, "ThinPlateSplineKernel{", Dim, "}()")
end

phi(::ThinPlateSplineKernel, r::Real) = iszero(r) ? 0.0 : r^2 * log(r)
order(::ThinPlateSplineKernel) = 2

@doc raw"""
	WendlandKernel{Dim}(k; shape_parameter = 1.0, d = Dim)

Wendland kernel with
```math
    \phi_{d,k}(r) = \begin{cases}
        p_{d,k}(\varepsilon r), \text{ if } 0\le \varepsilon r\le 1\\
        0, \text{ if } \varepsilon r > 1
    \end{cases},
```
where ``\varepsilon`` is the shape parameter and ``p`` is a polynomial with
minimal degree. The Wendland kernel is positive definite for `d\le Dim` and
compactly supported. See Wendland (2004), p. 129 or Fasshauer (2007), pp. 87--88.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
"""
struct WendlandKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    k::Int
    shape_parameter::RealT
    d::Int
end

function WendlandKernel{Dim}(k::Int; shape_parameter = 1.0, d::Int = Dim) where {Dim}
    @assert d<=Dim "d has to be smaller or equal to Dim"
    @assert k in 0:3 "kernel only implemented for k in 0:3"
    WendlandKernel{Dim, typeof(shape_parameter)}(k, shape_parameter, d)
end

function get_name(kernel::WendlandKernel)
    string(nameof(typeof(kernel))) * string(kernel.d) * "," * string(kernel.k) * "{" *
    string(dim(kernel)) * "}"
end

function Base.show(io::IO, kernel::WendlandKernel{Dim}) where {Dim}
    print(io, "WendlandKernel{", Dim, "}(k = ", kernel.k, ", shape_parameter = ",
          kernel.shape_parameter, ", d = ", kernel.d, ")")
end

function phi(kernel::WendlandKernel, r::RealT) where {RealT <: Real}
    a_r = kernel.shape_parameter * r
    if a_r >= 1
        return RealT(0.0)
    end
    l = floor(Int, kernel.d / 2) + kernel.k + 1
    if kernel.k == 0
        return (1 - a_r)^l
    elseif kernel.k == 1
        return (1 - a_r)^(l + 1) * ((l + 1) * a_r + 1)
    elseif kernel.k == 2
        return 1 // 3 * (1 - a_r)^(l + 2) *
               ((l^2 + 4 * l + 3) * a_r^2 + (3 * l + 6) * a_r + 3)
    elseif kernel.k == 3
        return 1 // 15 * (1 - a_r)^(l + 3) *
               ((l^3 + 9 * l^2 + 23 * l + 15) * a_r^3 + (6 * l^2 + 36 * l + 45) * a_r^2 +
                (15 * l + 45) * a_r + 15)
    end
end
order(::WendlandKernel) = 0

@doc raw"""
	WuKernel{Dim}(l, k; shape_parameter = 1.0)

Wu kernel with
```math
    \phi_{l,k}(r) = \begin{cases}
        p_{l,k}(\varepsilon r), \text{ if } 0\le \varepsilon r\le 1\\
        0, \text{ if } \varepsilon r > 1
    \end{cases},
```
where ``\varepsilon`` is the shape parameter, ``k\le l``, and ``p`` is a polynomial
of degree ``4l - 2k + 1``. The Wu kernel is positive definite for ``Dim\le 2k + 1``
and compactly supported. See Fasshauer (2007), pp. 88--90 and Wu (1995).

See also [`RadialSymmetricKernel`](@ref).

- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
- Zongmin Wu (1995)
  Compactly supported positive definite radial functions
  Advances in Computational Mathematics
  [DOI: 10.1007/BF03177517](https://doi.org/10.1007/BF03177517)
"""
struct WuKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    l::Int
    k::Int
    shape_parameter::RealT
end

function WuKernel{Dim}(l::Int, k::Int; shape_parameter = 1.0) where {Dim}
    @assert l>=k "l has to be bigger or equal to k"
    @assert l in 0:3 "kernel only implemented for l in 0:3"
    WuKernel{Dim, typeof(shape_parameter)}(l, k, shape_parameter)
end

function get_name(kernel::WuKernel)
    string(nameof(typeof(kernel))) * string(kernel.l) * "," * string(kernel.k) * "{" *
    string(dim(kernel)) * "}"
end

function Base.show(io::IO, kernel::WuKernel{Dim}) where {Dim}
    print(io, "WuKernel{", Dim, "}(l = ", kernel.l, ", k = ", kernel.k,
          ", shape_parameter = ", kernel.shape_parameter, ")")
end

function phi(kernel::WuKernel, r::RealT) where {RealT <: Real}
    a_r = kernel.shape_parameter * r
    if a_r >= 1
        return RealT(0.0)
    end
    if kernel.l == 0
        # k = 0
        return 1 - a_r
    elseif kernel.l == 1
        if kernel.k == 0
            return (1 - a_r)^3 * (a_r^2 + 3 * a_r + 1)
        elseif kernel.k == 1
            return 1 // 2 * (1 - a_r)^2 * (a_r + 2)
        end
    elseif kernel.l == 2
        if kernel.k == 0
            return (1 - a_r)^5 * (a_r^4 + 5 * a_r^3 + 9 * a_r^2 + 5 * a_r + 1)
        elseif kernel.k == 1
            return 1 // 4 * (1 - a_r)^4 * (3 * a_r^3 + 12 * a_r^2 + 16 * a_r + 4)
        elseif kernel.k == 2
            return 1 // 8 * (1 - a_r)^3 * (3 * a_r^2 + 9 * a_r + 8)
        end
    elseif kernel.l == 3
        if kernel.k == 0
            return 1 // 5 * (1 - a_r)^7 *
                   (5 * a_r^6 + 35 * a_r^5 + 101 * a_r^4 + 147 * a_r^3 + 101 * a_r^2 +
                    35 * a_r + 5)
        elseif kernel.k == 1
            return 1 // 6 * (1 - a_r)^6 *
                   (5 * a_r^5 + 30 * a_r^4 + 72 * a_r^3 + 82 * a_r^2 + 36 * a_r + 6)
        elseif kernel.k == 2
            return 1 // 8 * (1 - a_r)^5 *
                   (5 * a_r^4 + 25 * a_r^3 + 48 * a_r^2 + 40 * a_r + 8)
        elseif kernel.k == 3
            return 1 // 16 * (1 - a_r)^4 * (5 * a_r^3 + 20 * a_r^2 + 29 * a_r + 16)
        end
    end
end
order(::WuKernel) = 0

@doc raw"""
    RadialCharacteristicKernel{Dim}(beta = 2.0; shape_parameter = 1.0)

Radial characteristic function (or also called truncated power or Askey) kernel function with
```math
    \phi(r) = (1 - \varepsilon r)^\beta_+,
```
where ``\varepsilon`` is the shape parameter. The radial characteristic function is
positive definite if ``\beta\ge (d + 1)/2``. It is compactly supported.
See Wendland (2004), p. 80, Iske (2018), p. 281.

See also [`RadialSymmetricKernel`](@ref).

- Holger Wendland (2004)
  Scattered Data Approximation
  Cambridge University Press
  [DOI: 10.1017/CBO9780511617539](https://doi.org/10.1017/CBO9780511617539)
- Armin Iske (2018)
  Approximation Theory and Algorithms for Data Analysis
  Texts in Applied Mathematics (Springer)
  [DOI: 10.1007/978-3-030-05228-7](https://doi.org/10.1007/978-3-030-05228-7)
"""
struct RadialCharacteristicKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    beta::RealT
    shape_parameter::RealT
end

function RadialCharacteristicKernel{Dim}(beta = 2.0; shape_parameter = 1.0) where {Dim}
    RadialCharacteristicKernel{Dim, typeof(shape_parameter)}(beta, shape_parameter)
end

function Base.show(io::IO, kernel::RadialCharacteristicKernel{Dim}) where {Dim}
    print(io, "RadialCharacteristicKernel{", Dim, "}(beta = ", kernel.beta,
          ", shape_parameter = ", kernel.shape_parameter, ")")
end

function phi(kernel::RadialCharacteristicKernel, r::Real)
    max(0, 1 - kernel.shape_parameter * r)^kernel.beta
end
function order(kernel::RadialCharacteristicKernel{Dim}) where {Dim}
    kernel.beta > (Dim + 1) / 2 ? 0 : Inf
end

@doc raw"""
    MaternKernel{Dim}(nu = 1.5; shape_parameter = 1.0)

Matern kernel with
```math
    \phi_\nu(r) =  \frac{2^{1-\nu}}{\Gamma(\nu)}\big(\sqrt{2\nu}\varepsilon r\big)^\nu K_\nu\big(\sqrt{2\nu}\varepsilon r\big),
```
where ``\varepsilon`` is the shape parameter. The Matern kernel is positive definite.

See [Wikipedia](https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function) and Fasshauer (2007), p. 41.

See also [`RadialSymmetricKernel`](@ref).

- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
"""
struct MaternKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    nu::RealT
    shape_parameter::RealT
end

function MaternKernel{Dim}(nu = 1.5; shape_parameter = 1.0) where {Dim}
    MaternKernel{Dim, typeof(shape_parameter)}(nu, shape_parameter)
end

function Base.show(io::IO, kernel::MaternKernel{Dim}) where {Dim}
    print(io, "MaternKernel{", Dim, "}(nu = ", kernel.nu, ", shape_parameter = ",
          kernel.shape_parameter, ")")
end

# See https://github.com/JuliaGaussianProcesses/KernelFunctions.jl/blob/9a2f7bbec515c55e5594feef7928670cb811169c/src/basekernels/matern.jl#L42
function phi(kernel::MaternKernel, r::Real)
    nu = kernel.nu
    a_r = kernel.shape_parameter * r
    if iszero(r)
        c = -nu // (nu - 1)
        return one(a_r) + c * a_r^2 / 2
    else
        y = sqrt(2 * nu) * a_r
        b = log(besselk(nu, y))
        return exp((one(a_r) - nu) * oftype(y, log(2)) - loggamma(nu) + nu * log(y) + b)
    end
end
order(::MaternKernel) = 0

# Implement special Matern kernels for faster evaluation
@doc raw"""
	Matern12Kernel{Dim}(; shape_parameter = 1.0)

Matern kernel with ``\nu = 1/2``, i.e.,
```math
    \phi(r) = \exp(-\varepsilon r),
```
where ``\varepsilon`` is the shape parameter. The Matern kernel is positive definite.

See [Wikipedia](https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function) and Fasshauer (2007), p. 41.

See also [`MaternKernel`](@ref), [`RadialSymmetricKernel`](@ref).

- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
"""
struct Matern12Kernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    shape_parameter::RealT
end

function Matern12Kernel{Dim}(; shape_parameter = 1.0) where {Dim}
    Matern12Kernel{Dim, typeof(shape_parameter)}(shape_parameter)
end

function Base.show(io::IO, kernel::Matern12Kernel{Dim}) where {Dim}
    print(io, "Matern12Kernel{", Dim, "}(shape_parameter = ", kernel.shape_parameter, ")")
end

function phi(kernel::Matern12Kernel, r::Real)
    y = kernel.shape_parameter * r
    return exp(-y)
end
order(::Matern12Kernel) = 0

@doc raw"""
    Matern32Kernel{Dim}(; shape_parameter = 1.0)

Matern kernel with ``\nu = 3/2``, i.e.,
```math
    \phi(r) =  (1 + \sqrt{3}\varepsilon r)\exp(-\sqrt{3}\varepsilon r),
```
where ``\varepsilon`` is the shape parameter. The Matern kernel is positive definite.

See [Wikipedia](https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function) and Fasshauer (2007), p. 41.

See also [`MaternKernel`](@ref), [`RadialSymmetricKernel`](@ref).

- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
"""
struct Matern32Kernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    shape_parameter::RealT
end

function Matern32Kernel{Dim}(; shape_parameter = 1.0) where {Dim}
    Matern32Kernel{Dim, typeof(shape_parameter)}(shape_parameter)
end

function Base.show(io::IO, kernel::Matern32Kernel{Dim}) where {Dim}
    return print(io, "Matern32Kernel{", Dim, "}(shape_parameter = ",
                 kernel.shape_parameter, ")")
end

function phi(kernel::Matern32Kernel, r::RealT) where {RealT <: Real}
    y = RealT(sqrt(3)) * kernel.shape_parameter * r
    return (1 + y) * exp(-y)
end
order(::Matern32Kernel) = 0

@doc raw"""
    Matern52Kernel{Dim}(; shape_parameter = 1.0)

Matern kernel with ``\nu = 5/2``, i.e.,
```math
    \phi(r) =  (1 + \sqrt{5}\varepsilon r + 5\cdot(\varepsilon r)^2/3)\exp(-\sqrt{5}\varepsilon r),
```
where ``\varepsilon`` is the shape parameter. The Matern kernel is positive definite.

See [Wikipedia](https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function) and Fasshauer (2007), p. 41.

See also [`MaternKernel`](@ref), [`RadialSymmetricKernel`](@ref).

- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
"""
struct Matern52Kernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    shape_parameter::RealT
end

function Matern52Kernel{Dim}(; shape_parameter = 1.0) where {Dim}
    Matern52Kernel{Dim, typeof(shape_parameter)}(shape_parameter)
end

function Base.show(io::IO, kernel::Matern52Kernel{Dim}) where {Dim}
    print(io, "Matern52Kernel{", Dim, "}(shape_parameter = ", kernel.shape_parameter, ")")
end

function phi(kernel::Matern52Kernel, r::RealT) where {RealT <: Real}
    y = RealT(sqrt(5)) * kernel.shape_parameter * r
    return 1 // 3 * (3 + 3 * y + y^2) * exp(-y)
end
order(::Matern52Kernel) = 0

@doc raw"""
    Matern72Kernel{Dim}(; shape_parameter = 1.0)

Matern kernel with ``\nu = 7/2``, i.e.,
```math
    \phi(r) =  (1 + \sqrt{7}\varepsilon r + 12\cdot(\varepsilon r)^2/5 + 7\cdot(\varepsilon r)^3/15)\exp(-\sqrt{7}\varepsilon r),
```
where ``\varepsilon`` is the shape parameter. The Matern kernel is positive definite.

See [Wikipedia](https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function) and Fasshauer (2007), p. 41.

See also [`MaternKernel`](@ref), [`RadialSymmetricKernel`](@ref).

- Gregory Fasshauer (2007)
  Meshfree Approximation Methods with MATLAB
  World Scientific
  [DOI: 10.1142/6437](https://doi.org/10.1142/6437)
"""
struct Matern72Kernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    shape_parameter::RealT
end

function Matern72Kernel{Dim}(; shape_parameter = 1.0) where {Dim}
    Matern72Kernel{Dim, typeof(shape_parameter)}(shape_parameter)
end

function Base.show(io::IO, kernel::Matern72Kernel{Dim}) where {Dim}
    print(io, "Matern72Kernel{", Dim, "}(shape_parameter = ", kernel.shape_parameter, ")")
end

function phi(kernel::Matern72Kernel, r::RealT) where {RealT <: Real}
    y = RealT(sqrt(7)) * kernel.shape_parameter * r
    return (1 + y + 6 * y^2 / 15 + y^3 / 15) * exp(-y)
end
order(::Matern72Kernel) = 0

@doc raw"""
    RieszKernel{Dim}(beta; shape_parameter = 1.0)

Riesz kernel with
```math
    \phi(r) =  -(\varepsilon r)^\beta,
```
where ``\varepsilon`` is the shape parameter and ``\beta\in (0,2)``. The Riesz kernel is conditionally positive definite of order 1.
See Hertrich et al. (2023).

See also [`RadialSymmetricKernel`](@ref).

- Johannes Hertrich, Christian Wald, Fabian Altekrüger, Paul Hagemann (2023)
  Generative Sliced MMD Flows with Riesz Kernels
  [ArXiv: 2305.11463](https://arxiv.org/abs/2305.11463)
"""
struct RieszKernel{Dim, RealT} <: RadialSymmetricKernel{Dim}
    beta::RealT
    shape_parameter::RealT
end

function RieszKernel{Dim}(beta; shape_parameter = 1.0) where {Dim}
    @assert 0<beta<2 "beta has to be in (0, 2)"
    RieszKernel{Dim, typeof(shape_parameter)}(beta, shape_parameter)
end

function Base.show(io::IO, kernel::RieszKernel{Dim}) where {Dim}
    print(io, "RieszKernel{", Dim, "}(beta = ", kernel.beta, ", shape_parameter = ",
          kernel.shape_parameter, ")")
end

phi(kernel::RieszKernel, r::Real) = -r^kernel.beta
order(::RieszKernel) = 1
