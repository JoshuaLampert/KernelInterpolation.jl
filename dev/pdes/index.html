<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving PDEs by collocation · KernelInterpolation.jl</title><meta name="title" content="Solving PDEs by collocation · KernelInterpolation.jl"/><meta property="og:title" content="Solving PDEs by collocation · KernelInterpolation.jl"/><meta property="twitter:title" content="Solving PDEs by collocation · KernelInterpolation.jl"/><meta name="description" content="Documentation for KernelInterpolation.jl."/><meta property="og:description" content="Documentation for KernelInterpolation.jl."/><meta property="twitter:description" content="Documentation for KernelInterpolation.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/pdes/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/pdes/"/><link rel="canonical" href="https://JoshuaLampert.github.io/KernelInterpolation.jl/stable/pdes/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KernelInterpolation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../nodesets/">Sets of nodes</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li class="is-active"><a class="tocitem" href>Solving PDEs by collocation</a><ul class="internal"><li><a class="tocitem" href="#Stationary-PDEs"><span>Stationary PDEs</span></a></li><li><a class="tocitem" href="#Time-dependent-PDEs"><span>Time-dependent PDEs</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_differentiating_interpolation/">1D interpolation and differentiation</a></li><li><a class="tocitem" href="../tutorial_noisy_data/">Dealing with noisy data</a></li></ul></li><li><a class="tocitem" href="../development/">Development</a></li><li><a class="tocitem" href="../ref/">Reference</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Guide</a></li><li class="is-active"><a href>Solving PDEs by collocation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving PDEs by collocation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/docs/src/pdes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solving-PDEs-by-collocation"><a class="docs-heading-anchor" href="#Solving-PDEs-by-collocation">Solving PDEs by collocation</a><a id="Solving-PDEs-by-collocation-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-PDEs-by-collocation" title="Permalink"></a></h1><p>Kernel methods are also suitable to solve partial differential equations (PDEs), which is also sometimes known as Hermite-Birkhoff interpolation, a special case of generalized interpolation. In an abstract setting generalized interpolation deals with the following problem: Given a Hilbert space <span>$H$</span> and a set of functionals <span>$\{\lambda_i\}_{i = 1}^N\subset H^*$</span> (<span>$H^*$</span> being the dual space), find a function <span>$s\in H$</span> such that <span>$\lambda_i(s) = f_i$</span> for <span>$i = 1,\ldots,N$</span> for given function values <span>$f_i$</span>. <a href="../interpolation/#classical_interpolation">Classical interpolation</a>, discussed in the previous section, corresponds to the case where <span>$H$</span> is a reproducing kernel Hilbert space (RKHS) and <span>$\lambda_i(s) = s(x_i)$</span> are point evaluations at the nodes <span>$x_i$</span> for <span>$X = \{x_i\}_{i = 1}^N$</span>. In the case of Hermite-Birkhoff interpolation, the functionals <span>$\lambda_i$</span> are not point evaluations but differential operators, which are applied to the function <span>$s$</span> and then evaluated at the nodes <span>$x_i$</span>.</p><p>The following is mostly based on the book by Fasshauer <sup class="footnote-reference"><a id="citeref-Fasshauer2015" href="#footnote-Fasshauer2015">[Fasshauer2015]</a></sup>.</p><h2 id="Stationary-PDEs"><a class="docs-heading-anchor" href="#Stationary-PDEs">Stationary PDEs</a><a id="Stationary-PDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Stationary-PDEs" title="Permalink"></a></h2><p>Consider the following general stationary PDE in a domain <span>$\Omega\subset\mathbb{R}^d$</span>:</p><p class="math-container">\[\mathcal{L}u = f,\]</p><p>where <span>$\mathcal{L}$</span> is a linear differential operator of order <span>$m$</span>, <span>$u$</span> is the unknown function and <span>$f$</span> is a given function. The operator <span>$\mathcal{L}$</span> can be written as</p><p class="math-container">\[\mathcal{L}u = \sum_{|\alpha|\leq m} a_\alpha D^\alpha u,\]</p><p>where <span>$D^\alpha = \partial_{x_1}^{\alpha_1}\cdots\partial_{x_d}^{\alpha_d}$</span> is a partial derivative of order <span>$|\alpha| = \alpha_1 + \cdots + \alpha_d$</span>. Note that in the context of PDEs we usually use the notation <span>$u$</span> for the unknown function instead of <span>$s$</span> as in the general interpolation problem. For a complete description of the PDE, we also need to specify boundary conditions on the boundary <span>$\partial\Omega$</span>, which can be written with a boundary operator <span>$\mathcal{B}$</span> as</p><p class="math-container">\[\mathcal{B}u = g,\]</p><p>where <span>$g$</span> is a given function. As boundary operator <span>$\mathcal{B}$</span> we usually consider the identity operator, which corresponds to Dirichlet boundary conditions. Like in the case of classical interpolation, we pick a set of nodes <span>$X_I = \{x_i\}_{i = 1}^{N_I}\subset\Omega$</span>. Due to the additional boundary conditions, we also pick a set of nodes <span>$X_B = \{x_i\}_{i = N_I + 1}^N\subset\partial\Omega$</span>. Let <span>$N = N_I + N_B$</span> and <span>$X = X_I\cup X_B$</span>. We again formulate an ansatz function <span>$u$</span> as a linear combination of basis functions. In the simplest case, we use the same linear combination (neglecting polynomial augmentation for simplicity), i.e.</p><p class="math-container">\[u(x) = \sum_{j = 1}^N c_jK(x, x_j),\]</p><p>where <span>$K$</span> is the kernel function. This approach is also known as non-symmetric collocation or Kansa&#39;s method. By enforcing the conditions <span>$\mathcal{L}u(x_i) = f(x_i)$</span> for <span>$i = 1,\ldots,N_I$</span> and <span>$\mathcal{B}u(x_i) = g(x_i)$</span> for <span>$i = N_I + 1,\ldots,N$</span> we obtain a linear system of equations for the coefficients <span>$c_i$</span>, which can be written as</p><p class="math-container">\[\begin{pmatrix}
\tilde{A}_L \\ \tilde{A}_B
\end{pmatrix}
c = \begin{pmatrix}
f_{X_I} \\ g_{X_B}
\end{pmatrix},\]</p><p>where <span>$\tilde{A}_L\in\mathbb{R}^{N_I\times N}$</span> and <span>$\tilde{A}_B\in\mathbb{R}^{N_I\times N}$</span> are the matrices corresponding to the conditions at the interior and boundary nodes, respectively, i.e.</p><p class="math-container">\[\begin{align*}
    (\tilde{A}_L)_{ij} &amp;= \mathcal{L}K(x_i, x_j), i = 1, \ldots, N_I, j = 1, \ldots, N \\
    (\tilde{A}_B)_{ij} &amp;= \mathcal{B}K(x_i, x_j), i = 1, \ldots, N_B, j = 1, \ldots, N.
\end{align*}\]</p><p>Since the kernel function is known and differentiable, we can compute the derivatives of <span>$K$</span> analytically.</p><div class="admonition is-info" id="Note-bb2d696afb36a139"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bb2d696afb36a139" title="Permalink"></a></header><div class="admonition-body"><p>In KernelInterpolation.jl, the derivatives of the kernel function are computed using automatic differentiation (AD) by using <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>. This allows for flexibility, simplicity, and easier extension, but it might be slower than computing the derivatives analytically. If you are interested in a more efficient implementation, you can have a look at the test set &quot;Differential operators&quot; in the <a href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/test/test_unit.jl">test suite of KernelInterpolation.jl</a>. This test set not only shows how to use analytical derivatives, but also how to define your own differential operators, which can be used to define custom PDEs.</p></div></div><p>Note, however, that the system matrix <span>$A = \begin{pmatrix} \tilde{A}_L \\ \tilde{A}_B \end{pmatrix}$</span> is not invertible in general because it not symmetric anymore as it was the case in the classical interpolation. Thus, this approach is also called non-symmetric collocation.</p><p>Let us see how this can be implemented in KernelInterpolation.jl by solving the Poisson equation <span>$-\Delta u = f$</span> in an L-shaped domain. We start by defining the equation (thus the differential operator) and the right-hand side. KernelInterpolation.jl already provides a set of predefined <a href="../ref/#api-diffops">differential operators</a> and <a href="../ref/#api-equations">equations</a>.</p><pre><code class="language-julia hljs">using KernelInterpolation

# right-hand-side of Poisson equation
f(x, equations) = 5 / 4 * pi^2 * sinpi(x[1]) * cospi(x[2] / 2)
pde = PoissonEquation(f)

# analytical solution of equation
u(x, equations) = sinpi(x[1]) * cospi(x[2] / 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u (generic function with 1 method)</code></pre><p>Next, we define the domain and the boundary of the L-shaped domain. We use a homogeneous grid for the nodes and filter the inner and boundary nodes in two separate <a href="../ref/#KernelInterpolation.NodeSet"><code>NodeSet</code></a>s.</p><pre><code class="language-julia hljs">function create_L_shape(N)
    x_min1 = (0.0, 0.0)
    x_max1 = (1 * pi, 1.0)
    x_min2 = (1 * pi, 0.0)
    x_max2 = (2 * pi, 1.0)
    x_min3 = (0.0, 1.0)
    x_max3 = (1 * pi, 2.0)
    nodeset1 = homogeneous_hypercube(N, x_min1, x_max1)
    nodeset2 = homogeneous_hypercube(N, x_min2, x_max2)
    nodeset3 = homogeneous_hypercube(N, x_min3, x_max3)
    nodeset = merge(nodeset1, nodeset2, nodeset3)
    unique!(nodeset)
    nodeset_inner = empty_nodeset(2)
    nodeset_boundary = empty_nodeset(2)
    for x in nodeset
        if x[1] == 0.0 || x[2] == 0.0 || x[2] == 2.0 || x[1] == 2.0 * pi || (x[1] == 1.0 * pi &amp;&amp; x[2] &gt;= 1.0) || (x[2] == 1.0 &amp;&amp; x[1] &gt;= pi)
            push!(nodeset_boundary, x)
        else
            push!(nodeset_inner, x)
        end
    end
    return nodeset_inner, nodeset_boundary
end
nodeset_inner, nodeset_boundary = create_L_shape(6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(NodeSet{2, Float64} with separation distance q = 0.09999999999999998 and 56 nodes, NodeSet{2, Float64} with separation distance q = 0.09999999999999998 and 40 nodes)</code></pre><p>Finally, we define the boundary condition, the kernel, and collect all necessary information in a <a href="../ref/#KernelInterpolation.SpatialDiscretization"><code>SpatialDiscretization</code></a>, which can be solved by calling the <a href="../ref/#KernelInterpolation.solve_stationary-Union{Tuple{SpatialDiscretization{Dim, RealT}}, Tuple{RealT}, Tuple{Dim}} where {Dim, RealT}"><code>solve_stationary</code></a> function.</p><pre><code class="language-julia hljs"># Dirichlet boundary condition (here taken from analytical solution)
g(x) = u(x, pde)

kernel = WendlandKernel{2}(3, shape_parameter = 0.3)
sd = SpatialDiscretization(pde, nodeset_inner, g, nodeset_boundary, kernel)
itp = solve_stationary(sd)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Interpolation with 96 nodes, kernel WendlandKernel{2}(k = 3, shape_parameter = 0.3, d = 2) and polynomial of order 0.</code></pre><p>The result <code>itp</code> is an <a href="../ref/#Interpolation"><code>Interpolation</code></a> object, which can be used to evaluate the solution at arbitrary points. We can save the solution on a finer grid to a VTK file and visualize it.</p><pre><code class="language-julia hljs">many_nodes_inner, many_nodes_boundary = create_L_shape(20)
many_nodes = merge(many_nodes_inner, many_nodes_boundary)
OUT = &quot;out&quot;
ispath(OUT) || mkpath(OUT)
vtk_save(joinpath(OUT, &quot;poisson_2d_L_shape&quot;), many_nodes, itp, x -&gt; u(x, pde);
         keys = [&quot;numerical&quot;, &quot;analytical&quot;])</code></pre><p>The resulting VTK file can be visualized with a tool like ParaView. After applying the filter <code>Warp by Scalar</code>, setting the coloring accordingly, and changing the &quot;Representation&quot; to &quot;Point Gaussian&quot;, we obtain the following visualization:</p><p><img src="../poisson_L_shape.png" alt="Poisson equation in an L shape domain"/></p><h2 id="Time-dependent-PDEs"><a class="docs-heading-anchor" href="#Time-dependent-PDEs">Time-dependent PDEs</a><a id="Time-dependent-PDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-PDEs" title="Permalink"></a></h2><p>KernelInterpolation.jl also supports the solution of time-dependent PDEs. The idea is to use the same approach as above for the spatial part of the PDE and then obtain an ordinary differential equation (ODE), which can be solved by some time integration method (method of lines). The general form of a time-dependent PDE is</p><p class="math-container">\[\partial_t u + \mathcal{L}u = f,\]</p><p>where <span>$\mathcal{L}$</span> is a linear differential operator of order <span>$m$</span> and <span>$f$</span> is a given function. The initial condition is given by <span>$u(x, 0) = u_0(x)$</span>. Boundary conditions are applied as before. Similar to the stationary case, we discretize the spatial part of the PDE by collocation and obtain a system of ODEs for the coefficients <span>$c_j$</span> of the basis functions, i.e. now the coefficients depend on time:</p><p class="math-container">\[u(t, x) = \sum_{j = 1}^N c_j(t)K(x, x_j),\]</p><p>where <span>$c_j(t)$</span> are the coefficients at time <span>$t$</span>. We again divide the spatial domain in a set of points in the inner domain <span>$X_I$</span> and at the boundary <span>$X_B$</span>. Plugging in the ansatz function into the PDE and the boundary conditions and evaluating at the nodes, we obtain the following system of ODEs and algebraic equations:</p><p class="math-container">\[\begin{align*}
    \partial_t u(t, x_i) &amp;= \sum_{j = 1}^N \partial_t c_j(t)K(x_i, x_j) = -\sum_{j = 1}^Nc_j(t)\mathcal{L}K(x_i, x_j) + f(x_i), i = 1, \ldots, N_I, \\
    0 &amp;= -\sum_{j = 1}^Nc_j(t)\mathcal{B}K(x_i, x_j) + g(x_i), i = N_I + 1, \ldots, N.
\end{align*}\]</p><p>These equations can be written compactly as a differential-algebraic equation (DAE) of the form</p><p class="math-container">\[Mc^\prime(t) = -Ac(t) + b\]</p><p>where <span>$c(t) = [c_1(t), \ldots, c_N(t)]^T$</span> is the vector of coefficients, <span>$M\in\mathbb{R}^{N\times N}$</span> is a (singular) mass matrix, <span>$A\in\mathbb{R}^{N\times N}$</span> is the system matrix, and <span>$b = \begin{pmatrix}f_{X_I}\\ g_{X_B}\end{pmatrix}\in\mathbb{R}^N$</span>. The matrices are given by</p><p class="math-container">\[M = \begin{pmatrix} \tilde{A_I}\\0\end{pmatrix} \quad\text{and}\quad A = \begin{pmatrix} \tilde{A_L}\\\tilde{A_B}\end{pmatrix},\]</p><p>where</p><p class="math-container">\[\begin{align*}
    \tilde{A_I}\in\mathbb{R}^{N_I\times N}, (\tilde{A_I})_{ij} &amp;= K(x_i, x_j),\\
    \tilde{A_L}\in\mathbb{R}^{N_I\times N}, (\tilde{A_L})_{ij} &amp;= \mathcal{L}K(x_i, x_j),\\
    \tilde{A_B}\in\mathbb{R}^{N_B\times N}, (\tilde{A_B})_{ij} &amp;= \mathcal{B}K(x_i, x_j).
\end{align*}\]</p><p>The coefficients for the initial conditions can be computed from the initial condition <span>$u_0(x)$</span> by solving the linear system</p><p class="math-container">\[\begin{pmatrix}
\tilde{A_I}\\\tilde{A_B}
\end{pmatrix}
c_0 = (u_0)_X.\]</p><p>For the solution of the DAE system, KernelInterpolation.jl uses the library <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>, which already provides a wide range of time integration methods. Note that this is a differential-algebraic equation (DAE) system, which is more difficult to solve than a simple ODE system. Thus, we are restricted to specialized time integration methods, which can handle DAEs. We recommend using the <code>Rodas5P</code> method, which is a Rosenbrock method for stiff DAEs. See also the <a href="https://docs.sciml.ai/DiffEqDocs/latest/tutorials/dae_example/">documentation of OrdinaryDiffEq.jl</a> for more information. <code>Rodas5P</code> along with other Rosenbrock methods are implemented in the subpackage OrdinaryDiffEqRosenbrock.jl. Therefore, we recommend using this package in combination with KernelInterpolation.jl to reduce precompile time. In order to solve DAEs with OrdinaryDiffEqRosenbrock.jl, we also need to import the subpackage OrdinaryDiffEqNonlinearSolve.jl.</p><p>In KernelInterpolation.jl, you can use the constructor of a <a href="../ref/#KernelInterpolation.Semidiscretization"><code>Semidiscretization</code></a> in a very similar way as <a href="../ref/#KernelInterpolation.SpatialDiscretization"><code>SpatialDiscretization</code></a>, but with the additional initial condition. This can be turned into an <code>ODEProblem</code> object from the OrdinaryDiffEq.jl ecosystem by calling <a href="../ref/#KernelInterpolation.semidiscretize-Tuple{Semidiscretization, Any}"><code>semidiscretize</code></a>. The resulting <code>ODEProblem</code> can then be solved by calling the <a href="https://docs.sciml.ai/DiffEqDocs/latest/basics/common_solver_opts/"><code>solve</code></a> function from OrdinaryDiffEq.jl. The resulting object is an <code>ODESolution</code> object, which can be transferred to a <a href="../ref/#KernelInterpolation.TemporalInterpolation"><code>TemporalInterpolation</code></a> by calling <code>TemporalInterpolation</code> on it. This object acts similarly to an <a href="../ref/#Interpolation"><code>Interpolation</code></a>, but has an additional time argument, e.g., <code>itp = titp(1.0)</code> gives an interpolation object <code>itp</code> from a temporal interpolation <code>titp</code> at time <code>t = 1.0</code>.</p><p>For a complete example of a time-dependent PDE, see, e.g., <a href="https://github.com/JoshuaLampert/KernelInterpolation.jl/blob/main/examples/PDEs/heat_2d_basic.jl">an example of the heat equation</a>. KernelInterpolation.jl provides <a href="../ref/#api-callbacks">some callbacks</a> that are can be passed to <code>solve</code> in order to call them during the time integration process. These can be used to monitor the solution or to save it to a file. To date, these are <a href="../ref/#KernelInterpolation.AliveCallback"><code>AliveCallback</code></a>, <a href="../ref/#KernelInterpolation.SaveSolutionCallback"><code>SaveSolutionCallback</code></a>, and <a href="../ref/#KernelInterpolation.SummaryCallback"><code>SummaryCallback</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Fasshauer2015"><a class="tag is-link" href="#citeref-Fasshauer2015">Fasshauer2015</a>Fasshauer (2015): Kernel-based Approximation Methods using MATLAB, World Scientific, <a href="https://doi.org/10.1142/9335">DOI: 10.1142/9335</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interpolation/">« Interpolation</a><a class="docs-footer-nextpage" href="../tutorial_differentiating_interpolation/">1D interpolation and differentiation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 08:45">Thursday 9 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
